<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
  body
  {
    font-family: arial, sans-serif;
    max-width: 6.75in;
    margin: 0px auto;
    font-size: 85%;
  }
   ins  {background-color: #CCFFCC; text-decoration: none;}
   del  {background-color: #FFCACA; text-decoration: none;}
   pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
   code {font-size: 110%; font-family: "courier new", courier, serif;}
   table {font-size: 90%;}
</style>
<title>UTF Conversion</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">DxxxxR0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-04-06<!--webbot bot="Timestamp" endspan i-checksum="12274" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>



<h2 >Requirements</h2>



<p ><b>[0] Break no existing code</b></p>



<p ><b>[1] No changes to the core language</b></p>



<p ><b>[2] No changes to the existing standard library</b></p>



<p ><b>[3] Support several use scenarios for <code>char</code>-based strings </b></p>
<ul>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  UTF-8 encoded.<ul>
  <li>Applies when UTF-8 is the default encoding for the operating system, and there 
  is no expectation of moving the code elsewhere, or</li>
  <li>Applies within a given section of code&nbsp;where <code>char</code>-based 
  strings are known to be UTF-8 encoded.</li>
</ul>



  </li>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  non-UTF-8 encoded..<ul>
  <li>Applies when the default encoding for the operating system is not UTF-8, and 
  there is no expectation of moving the code elsewhere.</li>
  <li>Applies within a given section of code where <code>char</code>-based strings are 
  known to be non-UTF-8 encoded.</li>
</ul>



  </li>
  <li>Portable code that must make no assumptions about the default encoding of <code>
  char</code> based strings</li>
</ul>



<p ><b>[4] Utilize existing codecvt facets for conversions to and from <code>char</code> based strings 
that are not UTF 
encoded </b></p>



<h2 >Design decisions</h2>



<p ><b>No changes to the core language</b></p>
<blockquote>



<p >Types <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, and
<code>wchar_t</code> remain unchanged, and there is no change to current 
requirements on their encodings.</p>



<p >No new core language character types are proposed.</p>
</blockquote>



<p ><b>Proposed changes to the standard library are pure additions</b></p>



<p >&nbsp;</p>



<p ><b>Its all about string encoding needs</b></p>



<p ><b>Provide three levels of functionality</b></p>
<blockquote>



<p >Provide high-level easy-to-use encoding conversion functions that handle 
everyday string interoperability needs. Keep the interfaces simple, but do 
support error handling customization since user needs vary widely.</p>



<p >Provide mid-level generic string encoding to support those requiring the 
full range of string interoperability needs.</p>



<p >Provide a low-level encoding conversion algorithm patterned after existing standard 
library algorithms for those who need to perform encoding conversions on 
sequences of characters.</p>
</blockquote>



<p ><b>Provide the three levels of functionality for both codecvt-based and UTF-based 
conversions</b></p>



<blockquote>



<p ><b>Codecvt-based</b> </p>



</blockquote>



<p ><b>Default error handling in favor of security.</b></p>



<p ><b>Provide a coherent error detection policy so that users know when they do 
and when they do not have to check for errors themselves</b></p>



<p ><b>Provide error checking functions so that users can easily check strings 
or sequences for valid UTF encoding.</b></p>
<p ><b>Default encoding is Unicode Transformation Format (UTF)</b></p>
<p >Unless otherwise specified, all functions in namespace <code>
unicode</code> assume UTF-8, UTF-16, and UTF-32 encoding for <code>char</code>,
<code>char16_t</code>, and <code>char32_t</code> strings, respectively.</p>
<p ><code>wchar_t</code> strings are encoded as UTF-8, UTF-16, or 
UTF-32, depending on the encoding of <code>wchar_t</code>.</p>
<p ><b>Do not provide basic_string&lt;&gt; to/from ostream/istream converting 
operator&lt;&lt;/operator&gt;&gt;</b></p>
<p >Users can use to_u8|u16|u32|w_string UTF conversion functions. Implicit 
conversions lull users into ignoring the costs.</p>
<h2 >Open questions</h2>
<p >If P0254, <i>Integrating <code>std::string_view</code> and <code>std::string</code></i>, 
is accepted, then the Proposed wording needs to be reviewed to verify that no 
changes are required.</p>
<h2>TODO</h2>
<p >TODO: Also provide throwing error handler. Design for exception type to be 
thrown.</p>
<p >TODO: Add function that scans a sequence / string for errors, reports 
results.</p>
<p >TODO: Follow Marshall&#39;s suggested return of pair&lt;&gt; from string algorithms?</p>
<p >TODO: UTF first, last, iterators are InputIterators? 
ForwardIterators? RandomAccess? Contiguous? What does basic_string_view require? How does iterator category interact with error handler? If the actual 
conversion is done by functions requiring const char* point to a contiguous 
string, to lesser categories of iterators actually work?</p>
<p >TODO: Add test cases for other kinds of strings to regression 
tests</p>
<p >TODO: add static asserts on character types, other requirements.</p>
<p >TODO: Arguments for error handler?</p>
<h2 >Bikeshed</h2>
<p >Namespace choice:</p>
<blockquote>
<p >utf<br>
unicode</p>
</blockquote>

<h2 >Proposed wording</h2>

<p>xxx</p>

<pre><!-- include "../include/boost/unicode/error.hpp" formatted snippet=error -->namespace boost
{
namespace unicode
{

  //  Error function objects are called with no arguments and either throw an
  //  exception or return a const pointer to a possibly empty C-style string.

  //  default error handler: function object returns a C-string of type
  //  ToCharT with a UTF encoded value of U+FFFD.
  template &lt;class CharT&gt; struct ufffd;
  template &lt;&gt; struct ufffd&lt;char&gt;;
  template &lt;&gt; struct ufffd&lt;char16_t&gt;;
  template &lt;&gt; struct ufffd&lt;char32_t&gt;;
  template &lt;&gt; struct ufffd&lt;wchar_t&gt;;

}  // namespace unicode
}  // namespace boost<!-- end include --></pre>

<p>xxx</p>

<pre>#include &lt;boost/unicode/error.hpp&gt;

<!-- include "../include/boost/unicode/codecvt_conversion.hpp" formatted snippet=codecvt -->namespace boost
{
namespace unicode
{
  //  codecvt_to_basic_string
  template &lt;class ToCharT, class FromCharT, class Codecvt,
    class FromTraits = std::char_traits&lt;FromCharT&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = std::char_traits&lt;ToCharT&gt;,
    class ToAlloc = std::allocator&lt;ToCharT&gt;,
    class View = boost::basic_string_view&lt;FromCharT, FromTraits&gt;&gt;
  inline std::basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    codecvt_to_basic_string(View v, const Codecvt&amp; ccvt,
                            Error eh=Error(), const ToAlloc&amp; a=ToAlloc());

  //  codecvt_to_string
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string
    codecvt_to_string(boost::wstring_view v,
                      const std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;&amp; ccvt,
                      const Error eh=Error());

  //  codecvt_to_wstring
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring
    codecvt_to_wstring(boost::string_view v,
                       const std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;&amp; ccvt,
                       const Error eh=Error());

}  // namespace unicode
}  // namespace boost<!-- end include --></pre>

<p>xxx</p>

<pre>#include &lt;boost/unicode/error.hpp&gt;

<!-- include "../include/boost/unicode/utf_conversion.hpp" formatted snippet=utfcvt -->namespace boost
{
namespace unicode
{

  //  convert_utf UTF conversion algorithms

  //    converts between UTF-8, UTF-16, UTF-32, and wchar_t encodings;
  //    char encoding must be UTF-8
  //    char16_t encoding must be UTF-16
  //    char32_t encoding must be UTF-32
  //    wchar_t encoding must be UTF-8, UTF-16, or UTF-32
  //    Remarks: Errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.
  //    Note: ToCharT cannot be inferred via
  //    std::iterator_traits&lt;OutputIterator&gt;::value_type
  //    because std::iterator_traits&lt;OutputIterator&gt;::value_type is void for
  //    OutputIterators such as back_inserter.
  template &lt;class ToCharT, class InputIterator, class OutputIterator,
    class Error = typename ufffd&lt;ToCharT&gt;&gt;
  inline OutputIterator
    convert_utf(InputIterator first, InputIterator last, 
      OutputIterator result, Error eh = Error());

  //  to_utf_string generic UTF string conversion functions

  //    Remarks: Performs the conversion by calling convert_utf.
  //    Note: This implies that errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.
  //    Note: See &quot;Probe CharTraits template argument deduction&quot; in test/smoke_test.cpp
  //    for why two overloads are needed for each form rather than providing a default
  //    template parameter for FromTraits. Short answer: With a default FromTraits
  //    parameter, template argument deduction fails.

  template &lt;class ToCharT, class FromCharT,
    class FromTraits = typename std::char_traits&lt;FromCharT&gt;,
    class View = boost::basic_string_view&lt;FromCharT, FromTraits&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = std::char_traits&lt;ToCharT&gt;,
    class ToAlloc = std::allocator&lt;ToCharT&gt;&gt;
  inline std::basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    to_utf_string(View v, Error eh = Error(), const ToAlloc&amp; a = ToAlloc());
  
  //  to_{u8|u16|u32|w}string convenience functions for UTF string conversions

  //    Remarks: Performs the converstion by calling to_utf_string
  //    Note: This implies that errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.

  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::wstring_view v, Error eh = Error());

}  // namespace unicode
}  // namespace boost<!-- end include --></pre>

<hr>

</body>

</html>