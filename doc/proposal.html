<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
  body
  {
    font-family: arial, sans-serif;
    max-width: 6.75in;
    margin: 0px auto;
    font-size: 85%;
  }
   ins  {background-color: #CCFFCC; text-decoration: none;}
   del  {background-color: #FFCACA; text-decoration: none;}
   pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
   code {font-size: 110%; font-family: "courier new", courier, serif;}
   table {font-size: 90%;}
</style>
<title>Unicode Encoding conversions</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">DxxxxR0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-05-11<!--webbot bot="Timestamp" endspan i-checksum="12329" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>



<h1 align="center">Unicode Encoding Conversions for the Standard Library</h1>

<p  style="margin-left:20%; margin-right:20%;">Proposes library conversion functions to ease interoperation between 
existing standard and use-defined string types or streams. Provides conversion functions 
for Unicode Transformation Format (UTF) 
encodings, designed for Unicode-centric applications. Provides conversion 
functions for legacy 
encodings with existing <code>codecvt</code> facets, designed for conversion to 
and from UTF encodings. Pure addition to the standard library. No changes to the 
core language or existing standard library components. Breaks no existing code. User customizable 
error handling with secure default. Implementation available. Suitable for 
either a Library TS or the standard itself.</p>


<h2>Table of contents</h2>



<h2>Introduction</h2>



<h2>Motivation</h2>



<h2>History</h2>



<h2>Implementation and use</h2>



<h2>Acknowledgements</h2>



<h2>Requirements</h2>



<p><b>[0] Break no existing code</b></p>



<p><b>[1] No changes to the core language</b></p>



<p><b>[2] No changes to the existing standard library</b></p>



<p><b>[3] Support several use scenarios for <code>char</code>-based strings </b></p>
<ul>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  UTF-8 encoded.<ul>
  <li>Applies when UTF-8 is the default encoding for the operating system, and there 
  is no expectation of moving the code elsewhere, or</li>
  <li>Applies within a given section of code&nbsp;where <code>char</code>-based 
  strings are known to be UTF-8 encoded.</li>
</ul>



  </li>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  non-UTF-8 encoded..<ul>
  <li>Applies when the default encoding for the operating system is not UTF-8, and 
  there is no expectation of moving the code elsewhere.</li>
  <li>Applies within a given section of code where <code>char</code>-based strings are 
  known to be non-UTF-8 encoded.</li>
</ul>



  </li>
  <li>Portable code that must make no assumptions about the default encoding of <code>
  char</code> based strings</li>
</ul>



<p><b>[4] Utilize existing codecvt facets for conversions to and from <code>char</code> based strings 
that are not UTF 
encoded </b></p>



<h2>Design decisions</h2>



<p><b>No changes to the core language</b></p>
<blockquote>



<p>Types <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, and
<code>wchar_t</code> remain unchanged, and there is no change to current 
requirements on their encodings.</p>



<p>No new core language character types are proposed.</p>
</blockquote>



<p><b>Proposed changes to the standard library are pure additions</b></p>



<p><b>Avoids unexpected hidden conversions</b></p>



<p><b>Its all about string encoding needs</b></p>



<p><b>Agnostic about which character type or UTF encoding is &quot;best&quot;.</b></p>



<p><b>Provide three levels of functionality</b></p>
<blockquote>



<p>Provide high-level easy-to-use encoding conversion functions that handle 
everyday string interoperability needs. Keep the interfaces simple, but do 
support error handling customization since user needs vary widely.</p>



<p>Provide mid-level generic string encoding to support those requiring the 
full range of string interoperability needs.</p>



<p>Provide a low-level encoding conversion algorithm patterned after existing standard 
library algorithms for those who need to perform encoding conversions on 
sequences of characters.</p>
</blockquote>



<p><b>Provide the three levels of functionality for both codecvt-based and UTF-based 
conversions</b></p>



<blockquote>



<p><b>Codecvt-based</b> </p>



</blockquote>



<p><b>Default error handling in favor of security.</b></p>



<p><b>Provide a coherent error detection policy so that users know when they do 
and when they do not have to check for errors themselves</b></p>



<p><b>Provide error checking functions so that users can easily check strings 
or sequences for valid UTF encoding.</b></p>
<p><b>Default encoding is Unicode Transformation Format (UTF)</b></p>
<p>Unless otherwise specified, all functions in namespace <code>
unicode</code> assume UTF-8, UTF-16, and UTF-32 encoding for <code>char</code>,
<code>char16_t</code>, and <code>char32_t</code> strings, respectively.</p>
<p><code>wchar_t</code> strings are encoded as UTF-8, UTF-16, or 
UTF-32, depending on the encoding of <code>wchar_t</code>.</p>
<p><b>Do not provide basic_string&lt;&gt; to/from ostream/istream converting 
operator&lt;&lt;/operator&gt;&gt;</b></p>
<p>Users can use to_u8|u16|u32|w_string UTF conversion functions. Implicit 
conversions lull users into ignoring the costs.</p>
<h2>Open questions</h2>
<p>If P0254, <i>Integrating <code>std::string_view</code> and <code>std::string</code></i>, 
is accepted, then the proposed wording needs to be reviewed to accommodate 
changes that may accrue. Such changes, if any, are expected to be minor.</p>
<h2>TODO</h2>
<p>TODO: Also provide throwing error handler. Design for exception type to be 
thrown.</p>
<p>TODO: Add function that scans a sequence / string for errors, reports 
results.</p>
<p>TODO: Follow Marshall&#39;s suggested return of pair&lt;&gt; from string algorithms?</p>
<p>TODO: UTF first, last, iterators are InputIterators? 
ForwardIterators? RandomAccess? Contiguous? What does basic_string_view require? How does iterator category interact with error handler? If the actual 
conversion is done by functions requiring const char* point to a contiguous 
string, to lesser categories of iterators actually work?</p>
<p>TODO: Add test cases for other kinds of strings to regression 
tests</p>
<p>TODO: add static asserts on character types, other requirements.</p>
<p>TODO: Arguments for error handler?</p>
<h2>Bikeshed</h2>
<p>Namespace choice:</p>
<blockquote>
<p>utf<br>
unicode</p>
</blockquote>

<h2>Proposed wording</h2>

<h3>Unicode standard</h3>

<p>The <i>Unicode Standard</i>,
<a href="http://www.unicode.org/versions/latest/">
www.unicode.org/versions/latest/</a>, is referenced below. [<i>Example:</i> "(Unicode 
3.4 D10)" refers to the Unicode Standard, Core Specification, chapter 3, section 
4, sub-section D10.&mdash;<i>End example</i>]</p>

<p>For convenience, portions of the Unicode Standard are quoted 
below. Any conflicts between those quotes and the Unicode Standard is 
unintentional and should be resolved by reference to the actual Unicode Standard 
document.</p>

<blockquote>

<p>[Note: For general questions related to Unicode transformations 
format (UTF), UTF-8, UTF-16, UTF-32, or byte order marks (BOM), see
<a href="http://unicode.org/faq/utf_bom.html">unicode.org/faq/utf_bom.html</a>.&mdash;<i>end note</i>]</p>

</blockquote>

<h3>Definitions</h3>

<h4>Code point (Unicode 3.4 D10)</h4>
<p>&quot;Any value in the Unicode codespace. Informally, a code point can be thought 
of as a Unicode character.&quot; </p>
<blockquote>
  <p>(Unicode Appendix A - Notational Conventions): </p>
  <p>&quot;In running text, an individual Unicode code point is expressed as U+n, 
  where n is four to six hexadecimal digits, using the digits 0–9 and uppercase 
  letters A–F (for 10 through 15, respectively). Leading zeros are omitted, 
  unless the code point would have fewer than four hexadecimal digits—for 
  example, U+0001, U+0012, U+0123, U+1234, U+12345, U+102345. </p>
  <p>[e.g] U+0416 is the Unicode code point for the character named CYRILLIC 
  CAPITAL LETTER ZHE.&quot; </p>
</blockquote>

<h4>Code unit (Unicode 3.9 D77)</h4>
<p>&quot;The minimal bit combination that can represent a unit of encoded text for 
processing or interchange. Code units are particular units of computer storage. 
... The Unicode Standard uses 8-bit code units in the UTF-8 encoding form, 
16-bit code units in the UTF-16 encoding form, and 32-bit code units in the 
UTF-32 encoding form.&quot;</p>
<blockquote>
  <p>[<i>Note:</i> In C++ one <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or 
  <code>char32_t</code> character holds one 
  code unit.
  One to four code units (type <code>char</code>) are required to hold a UTF-8 
  encoded code 
  point.
  One or two code units (type <code>char16_t</code>) are required to hold a UTF-16 encoded 
  code point.
  One code unit (type <code>char32_t</code>) is required to hold a UTF-32 code point. 
  Type <code>wchar_t</code> may use 8, 16, or 32-bit code units, encoded as 
  UTF-8, UTF-16, or UTF-32, respectively, so will  require 4, 2, or 1 code units
  to hold a code point depending on the encoding.&mdash;<i>end note</i>]</p>
</blockquote>

  <h4>UTF-8, UTF-16, and UTF-32 Unicode encoding forms</h4>
  <p>For the formal definitions see
  <a href="http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G7404">Section 
  3.9, Unicode Encoding Forms</a> in <em>The Unicode Standard</em>.</p>

<h3>Error handling</h3>

<p>The header &lt;boost/unicode/error.hpp&gt; provides the default error handling 
function object used by the other headers in this library.</p>

<p>In accordance with the Unicode Standard&#39;s recommendations, the default error 
handling function object <code>ufffd</code> returns 
U+FFFD REPLACEMENT CHARACTER as a single code point error marker.</p>

<blockquote>
  <p>[<i>Note:</i> The Unicode Standard provides detailed rationale for that 
  recommendation; essentially it is that other commonly used approaches, including 
  throwing exceptions, can be and have been used as a security attack vector.
  &mdash;<i>end note</i>]</p>
</blockquote>

<p>&nbsp;</p>

<pre><!-- include "../include/boost/unicode/error.hpp" formatted snippet=error -->namespace boost
{
namespace unicode
{

  //  Error function objects are called with no arguments and either throw an
  //  exception or return a const pointer to a possibly empty C-style string.

  //  default error handler: function object returns a C-string of type
  //  ToCharT with a UTF encoded value of U+FFFD.
  template &lt;class CharT&gt; struct ufffd;
  template &lt;&gt; struct ufffd&lt;char&gt;;
  template &lt;&gt; struct ufffd&lt;char16_t&gt;;
  template &lt;&gt; struct ufffd&lt;char32_t&gt;;
  template &lt;&gt; struct ufffd&lt;wchar_t&gt;;

}  // namespace unicode
}  // namespace boost<!-- end include --></pre>

<h3><code>codecvt</code> based conversion</h3>

<pre>#include &lt;boost/unicode/error.hpp&gt;

<!-- include "../include/boost/unicode/codecvt_conversion.hpp" formatted snippet=codecvt -->namespace boost
{
namespace unicode
{
  //  codecvt_to_basic_string
  template &lt;class ToCharT, class FromCharT, class Codecvt,
    class FromTraits = std::char_traits&lt;FromCharT&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = std::char_traits&lt;ToCharT&gt;,
    class ToAlloc = std::allocator&lt;ToCharT&gt;,
    class View = boost::basic_string_view&lt;FromCharT, FromTraits&gt;&gt;
  inline std::basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    codecvt_to_basic_string(View v, const Codecvt&amp; ccvt,
                            Error eh=Error(), const ToAlloc&amp; a=ToAlloc());

  //  codecvt_to_string
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string
    codecvt_to_string(boost::wstring_view v,
                      const std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;&amp; ccvt,
                      const Error eh=Error());

  //  codecvt_to_wstring
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring
    codecvt_to_wstring(boost::string_view v,
                       const std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;&amp; ccvt,
                       const Error eh=Error());

}  // namespace unicode
}  // namespace boost<!-- end include --></pre>

<h3>UTF conversion functions</h3>

<pre>#include &lt;boost/unicode/error.hpp&gt;

<!-- include "../include/boost/unicode/utf_conversion.hpp" formatted snippet=utfcvt -->namespace boost
{
namespace unicode
{

  //  convert_utf UTF conversion algorithms

  //    Remarks: Errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.
  //    Note: ToCharT cannot be inferred via
  //    std::iterator_traits&lt;OutputIterator&gt;::value_type
  //    because std::iterator_traits&lt;OutputIterator&gt;::value_type is void for
  //    OutputIterators such as back_inserter.
  template &lt;class ToCharT, class InputIterator, class OutputIterator,
    class Error = typename ufffd&lt;ToCharT&gt;&gt;
  inline OutputIterator
    convert_utf(InputIterator first, InputIterator last, 
      OutputIterator result, Error eh = Error());

  //  to_utf_string generic UTF string conversion functions

  //    Remarks: Performs the conversion as if by calling convert_utf.
  //    Note: This implies that errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.
  //    Note: See &quot;Probe CharTraits template argument deduction&quot; in test/smoke_test.cpp
  //    for why two overloads are needed for each form rather than providing a default
  //    template parameter for FromTraits. Short answer: With a default FromTraits
  //    parameter, template argument deduction fails.

  template &lt;class ToCharT, class FromCharT,
    class FromTraits = typename std::char_traits&lt;FromCharT&gt;,
    class View = boost::basic_string_view&lt;FromCharT, FromTraits&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = std::char_traits&lt;ToCharT&gt;,
    class ToAlloc = std::allocator&lt;ToCharT&gt;&gt;
  inline std::basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    to_utf_string(View v, Error eh = Error(), const ToAlloc&amp; a = ToAlloc());
  
  //  to_{u8|u16|u32|w}string convenience functions for UTF string conversions

  //    Remarks: Performs the conversion as if by calling to_utf_string
  //    Note: This implies that errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.

  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
  inline std::string  to_u8string(boost::wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
  inline std::u16string  to_u16string(boost::wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
  inline std::u32string  to_u32string(boost::wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
  inline std::wstring  to_wstring(boost::wstring_view v, Error eh = Error());

}  // namespace unicode
}  // namespace boost<!-- end include --></pre>

<p>These functions convert between sequences of the character types indicated in 
<i>UFT Conversions</i> table.</p>

<p>Errors in input encoding are detected, even when the input and output 
encodings are the same. The eh function object&#39;s returned sequence if any 
replaces the invalid input encoding in the output, even when the input and 
output encodings are the same. This implies that if the eh function object 
always returns a valid UTF character sequence, the overall function output 
sequence is a valid UTF sequence.<br>
&nbsp;</p>

<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="3">
    <p align="center"><b><i>UTF Conversions</i></b></td>
      </tr>
  <tr>
    <td><b>Value type</b></td>
    <td><b>Encoding</b></td>
    <td><b>Errors detected</b></td>
  </tr>
  <tr>
    <td><code>char</code></td>
    <td>UTF-8</td>
    <td><span style="background-color: #FFFF00">TBS</span></td>
  </tr>
  <tr>
    <td><code>char16_t</code></td>
    <td>UTF-16</td>
    <td><span style="background-color: #FFFF00">TBS</span></td>
  </tr>
  <tr>
    <td><code>char32_t</code></td>
    <td>UFT-32</td>
    <td><span style="background-color: #FFFF00">TBS</span></td>
  </tr>
  <tr>
    <td><code>wchar_t</code></td>
    <td>UTF-8, 16, or 32</td>
    <td><span style="background-color: #FFFF00">TBS</span></td>
  </tr>
</table>

<p>&nbsp;</p>

<h3>UTF based converting stream inserters and extractors</h3>

<pre><!-- include "../include/boost/unicode/stream.hpp" formatted snippet=synopsis -->namespace std
{

  //  basic_string_view overload
  template &lt;class ToCharT, class ToTraits, class FromCharT, class FromTraits&gt;
  inline typename boost::enable_if_c&lt;!boost::is_same&lt;ToCharT, FromCharT&gt;::value,
    basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
      operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os,
                 boost::basic_string_view&lt;FromCharT, FromTraits&gt; v);

  //  basic_string overload
  template &lt;class ToCharT, class ToTraits, class FromCharT, class FromTraits, class Alloc&gt;
  inline typename boost::enable_if_c&lt;!boost::is_same&lt;ToCharT, FromCharT&gt;::value,
    basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
      operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os,
                 const basic_string&lt;FromCharT, FromTraits, Alloc&gt;&amp; s);

  //  pointer overload
  //    works despite std basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(const void* p) overload
  template &lt;class ToCharT, class ToTraits, class FromCharT&gt;
  inline typename boost::enable_if_c&lt;!boost::is_same&lt;ToCharT, FromCharT&gt;::value,
    basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
      operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os, const FromCharT* p);

}  // namespace std<!-- end include --></pre>

<hr>

</body>

</html>