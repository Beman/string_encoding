<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
  body
  {
    font-family: arial, sans-serif;
    max-width: 6.75in;
    margin: 0px auto;
    font-size: 85%;
  }
   ins  {background-color: #CCFFCC; text-decoration: none;}
   del  {background-color: #FFCACA; text-decoration: none;}
   pre  {background-color: #D7EEFF; font-family: "courier new", courier, serif;}
   code {font-family: "courier new", courier, serif;}
   table {font-size: 90%;}
</style>
<title>Unicode Encoding conversions</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">DxxxxR0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-05-17<!--webbot bot="Timestamp" endspan i-checksum="12341" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>



<h1 align="center">Unicode Encoding Conversions for the Standard Library</h1>

<p  style="margin-left:20%; margin-right:20%;">Proposes library conversion functions to ease interoperation between 
existing standard and use-defined string types or streams. Provides conversion functions 
for Unicode Transformation Form (UTF) 
encodings, designed for Unicode-centric applications. Provides conversion 
functions for legacy 
encodings with existing <code>codecvt</code> facets, designed for conversion to 
and from UTF encodings. Pure addition to the standard library. No changes to the 
core language or existing standard library components. Breaks no existing code. User customizable 
error handling with secure default. Implementation available. Suitable for 
either a Library TS or the standard itself.</p>


<h2>Table of contents</h2>



<h2>Introduction</h2>



<h2>Motivation</h2>



<h2>History</h2>



<h2>Implementation and use</h2>



<h2>Acknowledgements</h2>



<h2>Requirements</h2>



<p><b>[0] Break no existing code</b></p>



<p><b>[1] No changes to the core language</b></p>



<p><b>[2] No changes to the existing standard library</b></p>



<p><b>[3] Support several use scenarios for <code>char</code>-based strings </b></p>
<ul>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  UTF-8 encoded.<ul>
  <li>Applies when UTF-8 is the default encoding for the operating system, and there 
  is no expectation of moving the code elsewhere, or</li>
  <li>Applies within a given section of code&nbsp;where <code>char</code>-based 
  strings are known to be UTF-8 encoded.</li>
</ul>



  </li>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  non-UTF-8 encoded..<ul>
  <li>Applies when the default encoding for the operating system is not UTF-8, and 
  there is no expectation of moving the code elsewhere.</li>
  <li>Applies within a given section of code where <code>char</code>-based strings are 
  known to be non-UTF-8 encoded.</li>
</ul>



  </li>
  <li>Portable code that must make no assumptions about the default encoding of <code>
  char</code> based strings</li>
</ul>



<p><b>[4] Utilize existing codecvt facets for conversions to and from <code>char</code> based strings 
that are not UTF 
encoded </b></p>



<h2>Design decisions</h2>



<p><b>No changes to the core language</b></p>
<blockquote>



<p>Types <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, and
<code>wchar_t</code> remain unchanged, and there is no change to current 
requirements on their encodings.</p>



<p>No new core language character types are proposed.</p>
</blockquote>



<p><b>Proposed changes to the standard library are pure additions</b></p>



<p><b>Avoids unexpected hidden conversions</b></p>



<p><b>Its all about string encoding needs</b></p>



<p><b>Agnostic about which character type or UTF encoding is &quot;best&quot;.</b></p>



<p><b>Provide three levels of functionality</b></p>
<blockquote>



<p>Provide high-level easy-to-use encoding conversion functions that handle 
everyday string interoperability needs. Keep the interfaces simple, but do 
support error handling customization since user needs vary widely.</p>



<p>Provide mid-level generic string encoding to support those requiring the 
full range of string interoperability needs.</p>



<p>Provide a low-level encoding conversion algorithm patterned after existing standard 
library algorithms for those who need to perform encoding conversions on 
sequences of characters.</p>
</blockquote>



<p><b>Provide the three levels of functionality for both codecvt-based and UTF-based 
conversions</b></p>



<blockquote>



<p><b>Codecvt-based</b> </p>



</blockquote>



<p><b>Default error handling in favor of security.</b></p>



<p><b>Provide a coherent error detection policy so that users know when they do 
and when they do not have to check for errors themselves</b></p>



<p><b>Provide error checking functions so that users can easily check strings 
or sequences for valid UTF encoding.</b></p>
<p><b>Default encoding is Unicode Transformation Form (UTF)</b></p>
<p>Unless otherwise specified, all functions in namespace <code>
unicode</code> assume UTF-8, UTF-16, and UTF-32 encoding for <code>char</code>,
<code>char16_t</code>, and <code>char32_t</code> strings, respectively.</p>
<p><code>wchar_t</code> strings are encoded as UTF-8, UTF-16, or 
UTF-32, depending on the encoding of <code>wchar_t</code>.</p>
<p><b>Do not provide basic_string&lt;&gt; to/from ostream/istream converting 
operator&lt;&lt;/operator&gt;&gt;</b></p>
<p>Users can use to_u8|u16|u32|w_string UTF conversion functions. Implicit 
conversions lull users into ignoring the costs.</p>
<h2>Open questions</h2>
<p>If P0254, <i>Integrating <code>std::string_view</code> and <code>std::string</code></i>, 
is accepted, then the proposed wording needs to be reviewed to accommodate 
changes that may accrue. Such changes, if any, are expected to be minor.</p>
<h2>TODO</h2>
<p>TODO: Also provide throwing error handler. Design for exception type to be 
thrown.</p>
<p>TODO: Add function that scans a sequence / string for errors, reports 
results.</p>
<p>TODO: Follow Marshall&#39;s suggested return of pair&lt;&gt; from string algorithms?</p>
<p>TODO: UTF first, last, iterators are InputIterators? 
ForwardIterators? RandomAccess? Contiguous? What does basic_string_view require? How does iterator category interact with error handler? If the actual 
conversion is done by functions requiring const char* point to a contiguous 
string, to lesser categories of iterators actually work?</p>
<p>TODO: Add test cases for other kinds of strings to regression 
tests</p>
<p>TODO: add static asserts on character types, other requirements.</p>
<p>TODO: Arguments for error handler?</p>
<h2>Bikeshed</h2>
<p>Namespace choice:</p>
<blockquote>
<p>utf<br>
unicode</p>
</blockquote>

<h2>Proposed wording</h2>

<h2>Unicode library</h2>

<h3>Normative references</h3>

<p>The <i>Unicode Standard</i>,
<a href="http://www.unicode.org/versions/latest/">
www.unicode.org/versions/latest/</a>, is indispensable for the application of 
this document.<sup><font face="Arial">[footnote]</font></sup> The latest edition
(including any amendments) applies. A reference to the Unicode Standard is 
written in the form &quot;(Unicode 3.4 D10)&quot; to refer to the Unicode Standard, Core 
Specification, chapter 3, section 4, sub-section D10.</p>

<p>For convenience, portions of the Unicode Standard are quoted 
herein. Any conflicts between those quotes and the Unicode Standard is 
unintentional and should be resolved by reference to the actual Unicode Standard 
document.</p>

<p><sup><font face="Arial">[Footnote]</font></sup> Unicode® is a registered 
trademark of Unicode, Inc. This information is given for the convenience of 
users of this document and does not constitute an endorsement by ISO or IEC of 
this product.</p>

<h3>Definitions</h3>

<h4>Code point (Unicode 3.4 D10)</h4>
<p>&quot;Any value in the Unicode codespace. Informally, a code point can be thought 
of as a Unicode character.&quot; </p>
<blockquote>
  <p>(Unicode Appendix A - Notational Conventions): </p>
  <p>&quot;In running text, an individual Unicode code point is expressed as U+n, 
  where n is four to six hexadecimal digits, using the digits 0–9 and uppercase 
  letters A–F (for 10 through 15, respectively). Leading zeros are omitted, 
  unless the code point would have fewer than four hexadecimal digits—for 
  example, U+0001, U+0012, U+0123, U+1234, U+12345, U+102345. </p>
  <p>[e.g] U+0416 is the Unicode code point for the character named CYRILLIC 
  CAPITAL LETTER ZHE.&quot; </p>
</blockquote>

<h4>Code unit (Unicode 3.9 D77)</h4>
<p>&quot;The minimal bit combination that can represent a unit of encoded text for 
processing or interchange. Code units are particular units of computer storage. 
... The Unicode Standard uses 8-bit code units in the UTF-8 encoding form, 
16-bit code units in the UTF-16 encoding form, and 32-bit code units in the 
UTF-32 encoding form.&quot;</p>
<blockquote>
  <p>[<i>Note:</i> In C++ one <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or 
  <code>char32_t</code> character holds one 
  code unit.
  One to four code units (type <code>char</code>) are required to hold a UTF-8 
  encoded code 
  point.
  One or two code units (type <code>char16_t</code>) are required to hold a UTF-16 encoded 
  code point.
  One code unit (type <code>char32_t</code>) is required to hold a UTF-32 code point. 
  Type <code>wchar_t</code> may use 8, 16, or 32-bit code units, encoded as 
  UTF-8, UTF-16, or UTF-32, respectively, so will  require 4, 2, or 1 code units
  to hold a code point depending on the encoding.&mdash;<i>end note</i>]</p>
</blockquote>

  <h4>Unicode encoding forms (Unicode 3.9)</h4>

  <p>&quot;The Unicode Standard supports three character encoding forms: UTF-32, 
  UTF-16, and UTF-8. Each encoding form maps the Unicode code points 
  U+0000..U+D7FF and U+E000..U+10FFFF to unique code unit sequences. The size of 
  the code unit is specified for each encoding form. This section (Unicode 3.9) 
  presents the formal definition of each of these encoding forms.&quot;</p>
  <p>For the formal definitions see
  <a href="http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G7404">Section 
  3.9, Unicode Encoding Forms</a> in <em>The Unicode Standard</em>. </p>

<p>[Note: For general questions related to Unicode transformation 
form (UTF), UTF-8, UTF-16, UTF-32, or byte order marks (BOM), see
<a href="http://unicode.org/faq/utf_bom.html">unicode.org/faq/utf_bom.html</a>.&mdash;<i>end note</i>]</p>

<h4>Well-formed (Unicode 3.9 D85)</h4>

<p>&quot;A Unicode code unit sequence that purports to be in a Unicode encoding form 
is called well-formed if and only if it does follow the specification of that 
Unicode encoding form.&quot;</p>

<h4>Minimal well-formed code unit subsequence (Unicode 3.9 D85a)</h4>

<p>&quot;A well-formed Unicode code unit sequence that maps to a single Unicode 
scalar value.</p>


<blockquote>
  <ul>
    <li>For UTF-8, see the specification in Unicode 3.9 D92 and Table 3-7.</li>
    <li>For UTF-16, see the specification in Unicode 3.9 D91.</li>
    <li>For UTF-32, see the specification in Unicode 3.9 D90.&quot;</li>
  </ul>
</blockquote>

<h3>Header &lt;experimental/unicode&gt; synopsis</h3>

<pre>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace unicode {

  //  Error function objects are called with no arguments and either throw an
  //  exception or return a const pointer to a possibly empty C-style string.

  //  default error handler: function object returns a C-string of type
  //  ToCharT with a UTF encoded value of U+FFFD.

  // [uni.err], error handling
  template &lt;class CharT&gt; struct ufffd;
  template &lt;&gt; struct ufffd&lt;char&gt;;
  template &lt;&gt; struct ufffd&lt;char16_t&gt;;
  template &lt;&gt; struct ufffd&lt;char32_t&gt;;
  template &lt;&gt; struct ufffd&lt;wchar_t&gt;;

  //    Remarks: Errors in input encoding are detected, even when the input
  //    and output encodings are the same. The eh function object's returned sequence if
  //    any replaces the invalid input encoding in the output, even when the input and
  //    output encodings are the same. This implies that if the eh function object always
  //    returns a valid UTF character sequence, the overall function output sequence is
  //    a valid UTF sequence.
  //    Note: ToCharT cannot be inferred via
  //    std::iterator_traits&lt;OutputIterator&gt;::value_type
  //    because std::iterator_traits&lt;OutputIterator&gt;::value_type is void for
  //    OutputIterators such as back_inserter.

  //  [uni.enc_cvt_alg], string encoding conversion algorithm
  template &lt;class ToCharT, class InputIterator, class OutputIterator,
    class Error = typename ufffd&lt;ToCharT&gt;&gt;
  OutputIterator convert_utf(InputIterator first, InputIterator last, 
                             OutputIterator result, Error eh = Error());

  //  [uni.enc_gen_cvt], string encoding generic conversions
  template &lt;class ToCharT, class FromCharT,
    class FromTraits = typename char_traits&lt;FromCharT&gt;,
    class View = basic_string_view&lt;FromCharT, FromTraits&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = char_traits&lt;ToCharT&gt;,
    class ToAlloc = allocator&lt;ToCharT&gt;&gt;
  basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    to_utf_string(View v, Error eh = Error(), const ToAlloc&amp; a = ToAlloc());

  template &lt;class ToCharT, class FromCharT, class Codecvt,
    class FromTraits = char_traits&lt;FromCharT&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = char_traits&lt;ToCharT&gt;,
    class ToAlloc = allocator&lt;ToCharT&gt;,
    class View = basic_string_view&lt;FromCharT, FromTraits&gt;&gt;
  basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    codecvt_to_basic_string(View v, const Codecvt&amp; ccvt,
                            Error eh=Error(), const ToAlloc&amp; a=ToAlloc());
  
  //  [uni.enc_conv_cvt], string encoding convenience conversions
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string codecvt_to_string(wstring_view v,
                      const codecvt&lt;wchar_t, char, mbstate_t&gt;&amp; ccvt,
                      const Error eh=Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring codecvt_to_wstring(string_view v,
                      const codecvt&lt;wchar_t, char, mbstate_t&gt;&amp; ccvt,
                      const Error eh=Error());

}  // namespace unicode
}  // namespace fundamentals_v2
}  // namespace experimental
}  // namespace std</pre>



<h3>String encoding conversion functions [uni.enc_cvt]</h3>

<p>Two forms of string encoding conversion functions are provided:</p>

<ul>
  <li> <i>UTF conversion functions</i> convert only between UTF encodings.</li>
  <li><i>Codecvt conversion functions</i> convert between encodings determined 
  by a codecvt facet (C++ [locale.codecvt]) of type <code>codecvt&lt;wchar_t,char,mbstate_t&gt;</code>.</li>
</ul>

<p>UTF conversion functions determine encoding based on value type. The 
relationship between value type and encoding is as specified by the following 
table:</p>

<blockquote>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="2">
    <p align="center"><b><i>UTF Conversions</i></b></td>
      </tr>
  <tr>
    <td><b>Value type</b></td>
    <td><b>Encoding</b></td>
  </tr>
  <tr>
    <td><code>char</code></td>
    <td>UTF-8</td>
  </tr>
  <tr>
    <td><code>char16_t</code></td>
    <td>UTF-16</td>
  </tr>
  <tr>
    <td><code>char32_t</code></td>
    <td>UFT-32</td>
  </tr>
  <tr>
    <td><code>wchar_t</code></td>
    <td>UTF-8, 16, or 32</td>
  </tr>
</table>
</blockquote>

<p>Codecvt conversion functions convert between any narrow encoding 
and the encoding of execution wide-character set (C++ [lex.charset]). [<i>Note:</i> 
Codecvt conversion functions are useful for converting between non-UTF narrow character 
encodings and a UTF encoded execution wide-character set. &mdash; <i>end note</i>]</p>



<p>&nbsp;</p>



<h4>Error handling [uni.err]</h4>

<p>&nbsp;</p>

<p>Errors in input encoding are detected, even when the input and output 
encodings are the same. The eh function object&#39;s returned sequence if any 
replaces the invalid input encoding in the output, even when the input and 
output encodings are the same. This implies that if the eh function object 
always returns a valid UTF character sequence, the overall function output 
sequence is a valid UTF sequence.<br>
&nbsp;</p>



<p>&nbsp;</p>

<pre>template &lt;class CharT&gt; struct ufffd;
template &lt;&gt; struct ufffd&lt;char&gt;;
template &lt;&gt; struct ufffd&lt;char16_t&gt;;
template &lt;&gt; struct ufffd&lt;char32_t&gt;;
template &lt;&gt; struct ufffd&lt;wchar_t&gt;;</pre>


<p><code>struct ufffd</code> provides the default error handling function object for the conversion functions. Each specialization shall provide a member function with the signature:</p>

<blockquote>


<p> <code>constexpr CharT* operator()() const noexcept;</code></p>

</blockquote>


<p>that returns the value indicated in the Specializations table: </p>

<blockquote>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
<tr><td colspan="2"><p align="center"><i><b>Specializations</b></i></td></tr>
<tr><td><i><b><code>CharT</code></b></i></td><td><i><b>Returns</b></i></td></tr>
<tr><td><code>char</code></td><td><code>u8&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>u&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>char32_t</code></td><td><code>U&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>wchar_t</code></td><td><code>L&quot;\uFFFD&quot;</code></td></tr>
</table>
</blockquote>

<p>In accordance with the Unicode Standard&#39;s recommendations (<span style="background-color: #FFFF00">need 
reference</span>), the default error 
handling function object <code>ufffd</code> returns U+FFFD REPLACEMENT CHARACTER as a single code point error marker.</p>

<blockquote>
  <p>[<i>Note:</i> U+FFFD REPLACEMENT CHARACTER is returned as the default 
  single code point error marker in accordance with the recommendations of the Unicode Standard. 
  The rationale given is essentially that other commonly used approaches, including 
  throwing exceptions, can be and have been used as security attack vectors.
  &mdash;<i>end note</i>]</p>
</blockquote>

<h4>String encoding conversion algorithm [uni.enc_cvt_alg]</h4>

<pre>template &lt;class ToCharT, class InputIterator, class OutputIterator,
          class Error = typename ufffd&lt;ToCharT&gt;&gt;
  OutputIterator convert_utf(InputIterator first, InputIterator last, 
                             OutputIterator result, Error eh = Error());</pre>
  <blockquote>
     <p><i>Effects:</i> For each minimal well-formed or ill-formed code unit 
     subsequence in the range [<code>first, last</code>):</p>
     <ul>
       <li>
       <p dir="ltr">If the code unit subsequence is well-formed, copies the 
       subsequence&#39;s Unicode scalar value by performing <code>*result++ = *u++</code> 
       where u is a <code>ToCharT*</code> pointing to the code units required to represent the 
       subsequence&#39;s Unicode 
       scalar value in the encoding form of <code>result</code>.</li>
       <li dir="ltr">
       <p dir="ltr">Otherwise, copies the null-terminated string returned by the <code>eh</code> function 
       object by performing <code>*result++ = *p++</code> for each successive 
       value of a pointer <code>p</code> to the returned string.</li>
     </ul>
     <p><i>Returns: </i><code>result</code>.</p>
     <p><i>Remarks:</i>&nbsp; The Unicode encoding form for the range [<code>first, 
     last</code>) is determined by <code>InputIterator</code> value type ([uni.enc_cvt]). The 
     Unicode encoding form for <code>result</code> is determined by <code>
     ToCharT</code> ([uni.enc_cvt]).</p>
  </blockquote>                           

<h4>String encoding generic conversions [uni.enc_gen_cvt]</h4>

<pre> template &lt;class ToCharT, class FromCharT,
    class FromTraits = typename char_traits&lt;FromCharT&gt;,
    class View = basic_string_view&lt;FromCharT, FromTraits&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = char_traits&lt;ToCharT&gt;,
    class ToAlloc = allocator&lt;ToCharT&gt;&gt;
  basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    to_utf_string(View v, Error eh = Error(), const ToAlloc&amp; a = ToAlloc());</pre>

  <blockquote>
     <p><i>Returns:</i> Equivalent to:</p>
     <blockquote>
     <p><code>basic_string&lt;ToCharT, ToTraits, ToAlloc&gt; tmp(a);<br>
     convert_utf&lt;ToCharT&gt;(v.cbegin(), v.cend(), back_inserter(tmp), eh);<br>
     return tmp;</code></p>
     </blockquote>
  </blockquote>                           

  <pre>template &lt;class ToCharT, class FromCharT, class Codecvt,
<span style="background-color: #FFFF00">Why is class Codecvt needed? Isn&#39;t it always </span><code><span style="background-color: #FFFF00">codecvt&lt;wchar_t, char, std::mbstate_t&gt;?</span></code>
    class FromTraits = char_traits&lt;FromCharT&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = char_traits&lt;ToCharT&gt;,
    class ToAlloc = allocator&lt;ToCharT&gt;,
    class View = basic_string_view&lt;FromCharT, FromTraits&gt;&gt;
  basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    codecvt_to_basic_string(View v, const Codecvt&amp; ccvt,
                            Error eh=Error(), const ToAlloc&amp; a=ToAlloc());</pre>

  <blockquote>
     <p><i>Effects:</i></p>
     <blockquote>
     <p>Converts the string described by <code>v</code> to a temporary 
     string of type <code>basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;</code> 
     by as many invocations of <code>ccvt.in</code> or
     <code>ccvt.out</code> as necessary to process all characters in
     <code>v</code>. If an invocation of <code>ccvt.in</code>
     or <code>ccvt.out</code> returns a result value of <code>error</code>, 
     invoke the <code>eh</code> function object and append the string it returns 
     to the temporary string before processing additional characters in
     <code>v</code>.</p>
     </blockquote>
     <p><i>Returns</i>: The temporary string created by <i>Effects</i>.</p>
  </blockquote>                           

<h4>String encoding convenience conversions [uni.enc_conv_cvt]</h4>

<pre>template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(wstring_view v, Error eh = Error());</pre>

  <blockquote>
     <p><i>Returns:</i> Equivalent to: </p>
     <blockquote>
     <p> <code>to_utf_string&lt;<i>r_value_type</i>,
     <i>v_value_type</i>, Error&gt;(v, eh)</code> where <i><code>r_value_type</code></i> 
     is <code>value_type</code> of the returned <code>basic_string</code> and <i>
     <code>v_value_type</code></i> is <code>value_type</code> of <code>v</code>.</p>
     </blockquote>
  </blockquote>                           

  <pre>template &lt;class Error = ufffd&lt;char&gt;&gt;
    string codecvt_to_string(wstring_view v,
                      const codecvt&lt;wchar_t, char, mbstate_t&gt;&amp; ccvt,
                      const Error eh=Error());</pre>

  <blockquote>
     <p><i>Returns:</i> Equivalent to: </p>
     <blockquote>
     <p> <code>codecvt_to_basic_string&lt;char, 
     wchar_t, std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;&gt;(v, ccvt, eh)</code>.</p>
     </blockquote>
  </blockquote>                           

   <pre>template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring codecvt_to_wstring(string_view v,
                      const codecvt&lt;wchar_t, char, mbstate_t&gt;&amp; ccvt,
                      const Error eh=Error());</pre>

   <blockquote>
     <i>Returns:</i> Equivalent to: 
     <blockquote>
       <p><code>codecvt_to_basic_string&lt;wchar_t, char, std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;&gt;(v, ccvt, eh)</code>.
       </p>
     </blockquote>
  </blockquote>                           

<h3>UTF based converting stream inserters and extractors</h3>

<p>&nbsp;</p>

<p><i><span style="background-color: #FFFF00">What do we do about </span>
<span style="background-color: #FFFF00">ADL</span><span style="background-color: #FFFF00"> 
if this goes in </span><span style="background-color: #FFFF00">std::experimental</span><span style="background-color: #FFFF00">::fundamentals_v2?</span></i></p>

<pre>namespace std
{

&nbsp; //&nbsp; basic_string_view overload
&nbsp; template &lt;class ToCharT, class ToTraits, class FromCharT, class FromTraits&gt;
&nbsp; typename enable_if_c&lt;!is_same&lt;ToCharT, FromCharT&gt;::value,
&nbsp;&nbsp;&nbsp; basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; basic_string_view&lt;FromCharT, FromTraits&gt; v);

&nbsp; //&nbsp; basic_string overload
&nbsp; template &lt;class ToCharT, class ToTraits, class FromCharT, class FromTraits, class Alloc&gt;
&nbsp; typename enable_if_c&lt;!is_same&lt;ToCharT, FromCharT&gt;::value,
&nbsp;&nbsp;&nbsp; basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const basic_string&lt;FromCharT, FromTraits, Alloc&gt;&amp; s);

&nbsp; //&nbsp; pointer overload
&nbsp; //&nbsp;&nbsp;&nbsp; works despite std basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(const void* p) overload
&nbsp; template &lt;class ToCharT, class ToTraits, class FromCharT&gt;
&nbsp; typename enable_if_c&lt;!is_same&lt;ToCharT, FromCharT&gt;::value,
&nbsp;&nbsp;&nbsp; basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os, const FromCharT* p);

}&nbsp; // namespace std</pre>

<hr>

</body>

</html>