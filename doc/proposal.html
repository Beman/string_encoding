<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
body
{
  font-family: arial, sans-serif;
  max-width: 6.75in;
  margin: 0px auto;
  font-size: 85%;
}
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
 code {font-family: "courier new", courier, serif;}
 table {font-size: 90%;}
</style>
<title>Unicode Encoding conversions</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">D</span><span style="background-color: #FFFF00">0353</span><span style="background-color:yellow">R1</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-08-28<!--webbot bot="Timestamp" endspan i-checksum="12536" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>



<h1 align="center">Unicode Friendly Encoding Conversions for the Standard Library (R1)</h1>

<p  style="margin-left:20%; margin-right:20%;">Proposes character encoding conversion 
and related functions to ease interoperability between  
strings and other sequences of character types <code>char</code>, <code>char16_t</code>, 
<code>char32_t</code>, and <code>wchar_t</code>. Support for Unicode 
Transformation Form (UTF) and wide character encodings is built-in, while narrow 
character encodings are supported via traditional codecvt facets. Pure addition to the standard library. 
No changes to the 
core language or existing standard library components. Breaks no existing code 
or ABI. Proposed wording 
provided. Specified in accordance with ISO/IEC 10646 and the Unicode Standard. Has been implemented. Suitable for 
either a library TS or the standard itself.</p>



<h2>Introduction and Motivation</h2>



<p>C++ types <code>char</code>, <code>char16_t</code>, 
and
<code>char32_t</code> support character and string literals encoded in 
Unicode Transformation Forms UTF-8, UTF-16, and UTF-32 respectively. Additional 
narrow character encodings are supported by the standard library&#39;s codecvt 
facets via&nbsp;conversion to type <code>wchar_t</code> wide character encoding.</p>



<p>Users may 
need to use multiple encodings in the same 
application, or even the same function. Yet neither the language nor the 
standard library provides a modern C++11 way to conveniently convert between these encodings. 
There is no equivalent to the ease with which the <code>std::to_string</code> 
family of functions can convert an arithmetic value to a string.</p>



<p>This proposal 
markedly eases the problems encountered by users due to the lack of convenient encoding conversion in the standard library. 
Knowledge of UTF-8, UTF-16, UTF-32, and the implementation defined <code>wchar_t</code> 
wide encoding is built-in to make the interface Unicode friendly. The interface meets the 
error handling requirements of the Unicode and ISO/IEC 10646 standards, and 
meets the error handling needs 
requested by Unicode experts.</p>



<h3>Example</h3>



  <p><b>Problem: </b>Given a third-party function <code>f()</code> that returns a UTF-8 
  encoded <code>std::string</code> from a database, and a function <code>g()</code> 
  from a different third-party that expects a UTF-16 encoded <code>std::u16string</code> as an argument, <code>
  call g()</code> with <code>f()</code> in a way that converts the string types 
  and encodings, and handles errors according to the best practices documented in 
  the Unicode standard.</p>
  <p><b>Using the proposal:</b></p>
  <blockquote>
  <p>
  <code>string u8str(f());</code>
  <code>
  &nbsp;// get a string that happens to be UTF-8 encoded<br>
  ...<br>
  g(<a href="#uni.conv_enc_cvt">to_u16string</a>(u8str)); // call a function 
  that requires UTF-16</code></p>
  </blockquote>
<p><b>Without the proposal, using only the standard library:</b> This might not 
be too difficult using a third-party library, but is surprisingly difficult 
using only the standard library. Unless the developer had enough Unicode 
experience to focus on error detection and to test against one of the existing 
UTF-8 test data sets, a roll-your-own solution would probably be very 
error-prone.</p>



<h2>Prior proposal</h2>



<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3398.html">
N3398</a>, <i>String Interoperation Library</i>, proposed a complete overhaul of 
the standard library&#39;s mechanisms for character encoding conversion. The 
proposal was discussed at the Portland meeting in 2012. Some aspects of the 
proposal drew strong support, such as improving Unicode string interoperability. 
Other aspects drew strong opposition, such as new low level functionality to 
replace <code>std::codecvt</code>. Clearly participants did not want N3398 - 
they wanted a different proposal, less overreaching and more focused on Unicode 
encoding conversions. Bill Plauger summed it up when he said something like 
&quot;Don&#39;t reinvent <code>codecvt</code>. That said, we should pick  a 
winner &mdash; Unicode.&quot;</p>



<p>The current proposal is completely new and not a revision of N3398.</p>



<h2>Revision history</h2>



<p><b>R1 - Pre-Issaquah mailing</b></p>



<ul>
  <li>Added <i><a href="#uni.enc_err_detect">Encoding error detection</a></i> 
  functions.</li>
  <li>Added <i><a href="#Requirements">Requirements</a></i> section.</li>
  <li>
  <p>Changed to assume the C++ WP will be changed to specify ISO/IEC 10646:2014, 
  and so that becomes the base document for references.</li>
</ul>



<p><b>R0 - pre-Oulu mailing</b></p>



<h2>Implementation</h2>



<p>A Boost licensed preliminary implementation is available at
<a href="https://github.com/beman/unicode/tree/std-proposal">github.com/beman/unicode/tree/std-proposal</a>.</p>



<h2>Acknowledgements</h2>



<p><span style="background-color: #FFFF00">Oulu</span><span style="background-color: #FFFF00"> 
small group</span></p>



<p><span style="background-color: #FFFF00">Tom</span></p>



<p>Alisdair Meredith, Eric Niebler, Howard Hinnant, Jeffrey Yasskin, 
Marshall Clow, PJ Plauger, and Stephan T. Lavavej participated in the Portland 
discussion of N3398. Many of the design decisions that have gone into the current 
proposal flow directly from the Portland discussion.</p>



<p>After the Portland meeting, Matt Austern sat down with Google&#39;s &quot;Unicode 
people&quot; to &quot;clarify things&quot;. His summary of that discussion was very helpful. 
Its guidance on error handling is  reflected in current  
proposal.</p>



<h2>Design decisions</h2>



<p><b>Limit this proposal to encoding conversion and other simple functionality</b></p>



  <ul>
    <li>Getting UTF encoding conversion right is hard enough without also coping 
    with other Unicode needs.</li>
    <li>No all-encompassing Unicode proposal is on the horizon.</li>
    <li>Other needs requested by domain experts, such as code point iterators, 
    are important enough to deserve their own proposals.</li>
    <li>Guidance from both the committee and domain experts clearly favors a 
    proposal focusing on UTF conversions.</li>
  </ul>



<p><b>Build in support for UTF-8, UTF16, UTF-32 and wide (i.e. <code>wchar_t</code>) 
encodings</b></p>
<ul>
  <li>The UTF encodings are a critical need for the standard to become Unicode 
  friendlier.</li>
  <li>Support for the implementation defined wide character encoding ensures 
  support for much existing code. </li>
</ul>



<p><b>Build in support for existing narrow/wide codecvt facets</b></p>
<ul>
  <li>Allows this brand-new library to immediately support non-UTF encodings 
  without having to repeat two decades of codecvt facet development.</li>
</ul>



<p><b>Provide two levels of functionality</b></p>
<blockquote>



<p>Differing user needs is the primary motivation for providing two levels of 
functionality. Meshing well with existing standard library components such as 
STL algorithms and the <code>to_string</code> family of functions is an additional 
benefit.</p>



<ul>
  <li>Provide high-level convenience encoding conversion functions that handle 
everyday string interoperability needs. Keep the interfaces simple. Example 
  of use:</li>
</ul>



<blockquote>



<blockquote>



<p><code>string u8str = u16str;</code></p>



</blockquote>



</blockquote>



<ul>
  <li>Provide mid-level generic string conversion functions to support those 
  requiring generic string interoperability needs. Example of use:</li>
</ul>



<blockquote>



<blockquote>



<p><i><code>To Be supplied</code></i></p>



</blockquote>



</blockquote>



<ul>
  <li>Provide a low-level encoding conversion algorithm patterned after existing standard 
library algorithms. Useful for users needing to perform encoding conversions on 
sequences of characters. Provides the underlying UTF encoding conversions for 
  the other functions. Example of use:</li>
</ul>
<blockquote>



<blockquote>



<p><i><code>To Be supplied</code></i></p>
</blockquote>
</blockquote>



</blockquote>



<p><b>Provide a coherent error detection and handling policy</b></p>



<ul>
  <li>Follow the Unicode standard&#39;s requirement that &quot;A conformant encoding form 
  conversion will treat any ill-formed code unit
  sequence as an error condition.&quot; (Unicode 3.9 D93 and C10).</li>
  <li>Provide a note to inform users of as to when they do and do not have to 
  explicitly check for errors themselves.</li>
  <li>Provide error checking functions so that users can also explicitly check for errors 
  to meet application needs.</li>
  <li>Handle errors via function objects to support the varied user needs 
  described by domain experts.</li>
  <li>Default error handler function object follows the Unicode standard&#39;s 
  recommendation of U+FFFD as a replacement character. Their rationale is that 
  the other common approaches, including throwing an exception, can be and have 
  been used as attack vectors.</li>
</ul>



<p><b>Provide encoding conversions as explicitly called non-member functions</b></p>



<ul>
  <li>Avoids possibly expensive hidden automatic encoding conversions in 
  unexpected places.</li>
  <li>Avoids the need to change existing standard library components.</li>
  <li>Meshes well with the other <code>to_string</code> functions already in the 
  standard library.</li>
</ul>



<p><b>Place the proposed components in namespace <code>unicode</code></b></p>



<ul>
  <li>Emphasizes that these functions assume <code>
  char</code> strings use a Unicode encoding.</li>
  <li>Signals that the committee cares about Unicode, but doesn&#39;t want to force 
  it on users who prefer other encodings.</li>
  <li>Provides a home for these and future Unicode specific functions.</li>
</ul>



<p><b>Keep interfaces neutral as to which character type or UTF encoding is 
&quot;best&quot;</b></p>



<ul>
  <li>



<p>Each of these encodings have uses where it is preferred or required, and all 
of these needs may appear in the same application. For example:</p>



  <ul>
    <li>UTF-8 is required by the API&#39;s for some operating systems.</li>
    <li>UTF-16 is required to interfacing with existing databases that use UTF-16 
    encoding.</li>
    <li>UTF-32 is preferred in code where every 
    Unicode code point being encoded as a single code unit is advantageous.</li>
  </ul>



  </li>
</ul>
<p><b>Base conformance and definitions on ISO/IEC 10646:2014</b></p>
<ul>
  <li>Rewriting specifications that are already covered by another standard, 
  and then trying to keep that wording in sync as the other standard evolves is the path 
  to insanity.</li>
</ul>
<p><b>Use variadic templates to minimize the interface surface area</b></p>
<ul>
  <li>Converting between each two pairs of five encodings (narrow, UTF-8, 
  UTF-16, UTF-32, wide) results in twenty-five possible conversion functions. 
  Providing conversion in both algorithm form and convenience function form 
  doubles the number of functions to fifty. Initial use of templates reduced the 
  number of functions quite a bit, but trial use of an implementation for real 
  work was discouraging.</li>
  <li>Use of variadic templates (i.e. a generative approach) reduced the 
  interface to two functions - one conversion algorithm and one <code>to_string</code> 
  convenience function. </li>
</ul>
<h2>Questions for the Library Evolution Working Group</h2>
<ul>
  <li>The specification for the <code>to_*string</code> convenience functions 
  could be reduced from 16 signatures to four signatures by changing the 
  argument types to SOURCE, and then specifying SOURCE as being any one of the 
  four current argument types. The implementors could comply by 
  supplying the full 16 signatures or by clever template metaprogramming. In other words, a less signatures versus 
  more complex wording tradeoff. Does the LEWG/LWG have a strong preference 
  either way?<br>
&nbsp;</li>
  <li>Should a second error handler that throws an exception be provided? 
  Although the <code>ufffd</code> error handler is clearly the best default,  applications that work with supposedly well-formed UTF encodings 
  may want an exception thrown if an ill-formed encoding is encountered.<br>
&nbsp;</li>
  <li>Should a new exception type such as <code>encoding_error</code> be provided?<br>
&nbsp;</li>
  <li>The Boost version will supply stream inserters and perhaps 
  extractors that perform encoding conversion. Would LEWG/LWG like to see a 
  similar proposal?</li>
</ul>
<blockquote>
  <blockquote>
<pre>#include &lt;boost/unicode/stream.hpp&gt;
u16string str16(u&quot;☺☺☺&quot;);
...
cout << str16 << '\n';  // automatic conversion to UTF-8</pre>
  </blockquote>
</blockquote>
<h2>To do</h2>
<ul>
  <li>Add arguments to error handler function objects:<ul>
    <li>The location of the error in the input sequence. Probably the iterator of 
  the point where the error was detected.</li>
    <li>The specifics of the error. Probably an error type enum for the specific 
  encoding form errors called out by the Unicode Standard.</li>
  </ul>
  </li>
  <li>Add Requirements sub-section that spells out the requirements on Error 
  function objects. Ck WP for the form.</li>
</ul>

<h2>Character encoding in the C++ standard</h2>
<p>The following extracts are from N4606.</p>
<p>Here is how we know that type <code>char</code> supports UTF-8 encoded 
characters, even though narrow character encoding may be something other than 
UTF-8:</p>
<blockquote>
  <p><font face="Times New Roman">A byte is at least large enough to contain any 
  member of the basic execution character set (2.3) and the eight-bit code units 
  of the Unicode UTF-8 encoding form... (</font>[intro.memory]
  <font face="Times New Roman">¶ 1)</font></p>
  <p><font FACE="LMRoman10-Regular" SIZE="2">An ordinary character literal that 
  contains a single </font><font FACE="LMRoman10-Italic" SIZE="2"><i>c-char </i>
  </font><font FACE="LMRoman10-Regular" SIZE="2">representable in the execution 
  character set has type </font><font FACE="LMMono10-Regular" SIZE="2">char</font><font FACE="LMRoman10-Regular" SIZE="2">, 
  with value equal to the numerical value of the encoding of the </font>
  <font FACE="LMRoman10-Italic" SIZE="2"><i>c-char </i></font>
  <font FACE="LMRoman10-Regular" SIZE="2">in the execution character set. </font>
  <font face="Times New Roman">([lex.ccon] ¶ 2)</font></p>
  <p><font FACE="LMRoman10-Regular" SIZE="2">The value of a UTF-8 character 
  literal is equal to its ISO 10646 code point value, provided that the code 
  point value is representable with a single UTF-8 code unit (that is, provided 
  it is in the C0 Controls and Basic Latin Unicode block).</font><font face="Times New Roman"> 
  ([lex.ccon] ¶ 3) </font></p>
  <p><font face="Times New Roman">For a UTF-8 string literal, each successive 
  element of the object representation (3.9) has the value of the corresponding 
  code unit of the UTF-8 encoding of the string. ([lex.string] ¶ 9)</font></p>
</blockquote>
<p>Here is how we know that type <code>char16_t</code> supports UTF-16 encoded 
characters and <code>char16_t</code> literals are encoded in UTF-16:</p>
<blockquote>
  <p><font face="Times New Roman">The value of a char16_t literal containing a 
  single c-char is equal to its ISO 10646 code point value, provided that the 
  code point is representable with a single 16-bit code unit. (That is, provided 
  it is a basic multi-lingual plane code point.)&nbsp; ([lex.ccon] ¶ 4) </font>
  </p>
  <p><font face="Times New Roman">A char16_t string literal has type “array of n 
  const char16_t”, where n is the size of the string as defined below; it is 
  initialized with the given characters. A single c-char may produce more than 
  one char16_t character in the form of surrogate pairs.&nbsp; ([lex.string] ¶ 
  10)</font></p>
  <font FACE="LMRoman10-Regular" SIZE="2">
  <p ALIGN="LEFT">Within </font><font FACE="LMMono10-Regular" SIZE="2">char32_t
  </font><font FACE="LMRoman10-Regular" SIZE="2">and </font>
  <font FACE="LMMono10-Regular" SIZE="2">char16_t </font>
  <font FACE="LMRoman10-Regular" SIZE="2">literals, any</font><font FACE="LMRoman10-Italic" SIZE="2"><i> 
  universal-character-name</i></font><font FACE="LMRoman10-Regular" SIZE="2">s 
  shall be within the range </font><font FACE="LMMono10-Regular" SIZE="2">0x0
  </font><font FACE="LMRoman10-Regular" SIZE="2">to </font>
  <font FACE="LMMono10-Regular" SIZE="2">0x10FFFF</font><font FACE="LMRoman10-Regular" SIZE="2">.
  </font><font face="Times New Roman">([lex.string] ¶ 15)</font></p>
</blockquote>
<font FACE="LMRoman10-Regular" SIZE="2">
<p ALIGN="LEFT">Here is how we know that type <code>char32_t</code> supports 
UTF-32 encoded characters and <code>char32_t</code> literals are encoded in 
UTF-32:</p>
<blockquote>
  <p ALIGN="LEFT">The value of a </font><font FACE="LMMono10-Regular" SIZE="2">
  char32_t </font><font FACE="LMRoman10-Regular" SIZE="2">literal containing a 
  single </font><font FACE="LMRoman10-Italic" SIZE="2"><i>c-char </i></font>
  <font FACE="LMRoman10-Regular" SIZE="2">is equal to its ISO 10646 code point 
  value.</font><font face="Times New Roman">&nbsp; ([lex.ccon] ¶ 5) </font></p>
  <p ALIGN="LEFT"><font face="Times New Roman">A char32_t string literal has 
  type “array of n const char32_t”, where n is the size of the string as defined 
  below; it is initialized with the given characters. ([lex.string] ¶ 11)</font></p>
  <p ALIGN="LEFT"><font FACE="LMRoman10-Regular" SIZE="2">Within </font>
  <font FACE="LMMono10-Regular" SIZE="2">char32_t </font>
  <font FACE="LMRoman10-Regular" SIZE="2">and </font>
  <font FACE="LMMono10-Regular" SIZE="2">char16_t </font>
  <font FACE="LMRoman10-Regular" SIZE="2">literals, any</font><font FACE="LMRoman10-Italic" SIZE="2"><i> 
  universal-character-name</i></font><font FACE="LMRoman10-Regular" SIZE="2">s 
  shall be within the range </font><font FACE="LMMono10-Regular" SIZE="2">0x0
  </font><font FACE="LMRoman10-Regular" SIZE="2">to </font>
  <font FACE="LMMono10-Regular" SIZE="2">0x10FFFF</font><font FACE="LMRoman10-Regular" SIZE="2">.
  </font><font face="Times New Roman">([lex.string] ¶ 15)</font></p>
</blockquote>
<p>Here is how we know that type <font face="Times New Roman">wchar_t</font> 
supports the <font FACE="LMRoman10-Regular" SIZE="2">ISO/IEC 10646 (i.e. 
Unicode) character set</font>, even though the encoding may be implementation 
defined:</p>
<blockquote>
  <p>Type wchar_t is a distinct type whose values can represent distinct codes 
  for all members of the largest extended character set specified among the 
  <b>supported locales</b> (22.3.1). ([basic.fundamental]<font face="Times New Roman"> 
  ¶ 5</font>) </p>
  <p><i><span style="background-color: #00CC66">Presumably the supported locales 
  include locales that can use the [locale.stdcvt] facets. These facets have </span></i>
  <code><span style="background-color: #00CC66">Maxcode</span><span style="background-color: #00CC66"> 
  = 0x10ffff</span></code><i><span style="background-color: #00CC66"> as a 
  default, while </span></i><font face="Times New Roman">
  <span style="background-color: #00CC66">¶ 3.2 specifies that &quot;Maxcode is the 
  largest wide-character code that the facet will read or write without 
  reporting a conversion error&quot;.</span></font></p>
  <p><font face="Times New Roman">A wide-character literal has type wchar_t. The 
  value of a wide-character literal containing a single c-char has value equal 
  to the numerical value of the encoding of the c-char in the execution 
  wide-character set, unless the c-char has no representation in the execution 
  wide-character set, in which case the value is implementation-defined. [ Note: 
  The type wchar_t is able to represent all members of the execution 
  wide-character set (see 3.9.1). —end note ]&nbsp; ([lex.ccon] ¶ 6)</font></p>
  <p><font face="Times New Roman">The value of a character literal is 
  implementation-defined if it falls outside of the implementation-defined range 
  defined for char (for literals with no prefix) or wchar_t (for literals 
  prefixed by L). ([lex.ccon] ¶ 8)</font></p>
  <font FACE="LMRoman10-Regular" SIZE="2">
  <p ALIGN="LEFT">A </font><font FACE="LMRoman10-Italic" SIZE="2"><i>
  universal-character-name </i></font><font FACE="LMRoman10-Regular" SIZE="2">is 
  translated to the encoding, in the appropriate execution character set, of the 
  character named. If there is no such encoding, the </font>
  <font FACE="LMRoman10-Italic" SIZE="2"><i>universal-character-name </i></font>
  <font FACE="LMRoman10-Regular" SIZE="2">is translated to an 
  implementation-defined encoding.</font><font face="Times New Roman"> ([lex.ccon] 
  ¶ 9)&nbsp; </font></p>
  <p><font face="Times New Roman">A string-literal that begins with L, such as 
  L&quot;asdf&quot;, is a wide string literal. A wide string literal has type “array of n 
  const wchar_t”, where n is the size of the string as defined below; it is 
  initialized with the given characters. ([lex.string] ¶ 12)</font></p>
  <font FACE="LMRoman10-Regular" SIZE="2">
  <p ALIGN="LEFT">The size of a </font><font FACE="LMMono10-Regular" SIZE="2">
  char32_t </font><font FACE="LMRoman10-Regular" SIZE="2">or wide string literal 
  is the total number of escape sequences, </font>
  <font FACE="LMRoman10-Italic" SIZE="2"><i>universal-character-name</i></font><font FACE="LMRoman10-Regular" SIZE="2">s, 
  and other characters, plus one for the terminating </font>
  <font FACE="LMMono10-Regular" SIZE="2">U’\0’ </font>
  <font FACE="LMRoman10-Regular" SIZE="2">or </font>
  <font FACE="LMMono10-Regular" SIZE="2">L’\0’</font><font FACE="LMRoman10-Regular" SIZE="2">.
  </font><font face="Times New Roman">([lex.string] ¶ 15)</font></p>
  <font FACE="LMMono10-Regular" SIZE="2">
  <p ALIGN="LEFT">__STDC_ISO_10646__ </font>
  <font FACE="LMRoman10-Regular" SIZE="2">&nbsp; An integer literal of the form
  </font><font FACE="LMMono10-Regular" SIZE="2">yyyymmL </font>
  <font FACE="LMRoman10-Regular" SIZE="2">(for example, </font>
  <font FACE="LMMono10-Regular" SIZE="2">199712L</font><font FACE="LMRoman10-Regular" SIZE="2">). 
  If this symbol is defined, then every character in the Unicode required set, 
  when stored in an object of type </font>
  <font FACE="LMMono10-Regular" SIZE="2">wchar_t</font><font FACE="LMRoman10-Regular" SIZE="2">, 
  has the same value as the short identifier of that character. The </font>
  <font FACE="LMRoman10-Italic" SIZE="2"><i>Unicode required set </i></font>
  <font FACE="LMRoman10-Regular" SIZE="2">consists of all the characters that 
  are defined by ISO/IEC 10646, along with all amendments and technical 
  corrigenda as of the specified year and month.&nbsp; ([cpp.predefined]</font><font face="Times New Roman"> 
  ¶ 2</font><font FACE="LMRoman10-Regular" SIZE="2">) <i>&nbsp;In other words, 
  if defined </i>
</font>

  <font FACE="LMMono10-Regular" SIZE="2">
  __STDC_ISO_10646__ <i>tells us that wchar_t is UTF-32 encoded.</i></font></p>
</blockquote>

<h1>Proposed wording</h1>

<p><i><span style="background-color: #C0C0C0">This wording assumes P0417,</span></i><span style="background-color: #C0C0C0"> 
&quot;C++17 should refer to ISO/</span><span style="background-color: #C0C0C0">IEC</span><span style="background-color: #C0C0C0"> 
10646 2014 instead of 1994&quot;, </span><i><span style="background-color: #C0C0C0">
has been accepted into the C++ working paper.</span></i></p>

<h2>Unicode library [ucs]</h2>

<p>This sub-clause describes components that C++ programs may use to perform 
operations on characters, strings, and other sequences of characters encoded in 
various encoding forms. Encoding forms UTF-8, UTF-16, and UTF-32 are supported, as are  narrow 
character encodings having a <code>codecvt</code> facet meeting requirements 
described below.</p>

<p>[<i>Note:</i> The C++ standard does not require that the encoding of <code>
char</code>, <code>char16_t</code>, <code>char32_t</code>, and <code>wchar_t</code> 
objects be one of the UTF encodings. The components in this sub-clause use the 
provided types <code>narrow</code>, <code>utf8</code>, <code>utf16</code>, <code>utf32</code>, and 
<code>wide</code> to identify specific 
encodings [uni.relationships]. &mdash; <i>end note</i>]</p>

<h3>Normative references [ucs.refs]</h3>

<p>Within this sub-clause a reference written in the form &quot;(UCS <i>number</i>)&quot; refers to section <i>
number</i> of ISO/IEC 10646:2014 (C++ [intro.refs]).</p>

<p>[<i>Note</i>: ISO/IEC 10646 Universal Coded 
Character Set (UCS) is the ISO/IEC standard for
<a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a>. It is synchronized 
with <i>The Unicode Standard</i> maintained by the Unicode Consortium. &mdash;<i>end note</i>]</p>

<p><sup><font face="Arial">[Footnote]</font></sup> Unicode® is a registered 
trademark of Unicode, Inc. This information is given for the convenience of 
users of this document and does not constitute an endorsement by ISO or IEC of 
this product.</p>

<h3>Definitions&nbsp; [ucs.defs]</h3>

<p>The definitions from (UCS 4.) apply throughout. [<i>Examples: </i>code point (UCS 4.10), 
code unit 
(UCS 4.11), encoding form (UCS 4.23), ill-formed code unit sequence (UCS 4.33), 
minimal well-formed code unit sequence (UCS 4.41), well-formed code unit 
sequence (UCS 4.61).&nbsp; &mdash;<i>end examples</i>]</p>

<p>Throughout this sub-clause <code>char</code>, <code>char16_t</code>, <code>
char32_t</code>, and&nbsp; <code>wchar_t</code> are collectively called <i>
encoded character types</i>.</p>

<h3>Requirements [ucs.req]</h3>

<p>Template parameters named <code>InputIterator</code> shall satisfy the requirements of an input iterator (C++ [input.iterators]).</p>

<p>Template parameters named <code>OutputIterator</code> shall satisfy the 
requirements of an output iterator (C++ [output.iterators]).</p>

<h3>Header &lt;experimental/unicode&gt; synopsis</h3>

<pre>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace unicode {

  // [uni.err], default error handler
  template &lt;class CharT&gt; struct ufffd;
  template &lt;&gt; struct ufffd&lt;char&gt;;
  template &lt;&gt; struct ufffd&lt;char16_t&gt;;
  template &lt;&gt; struct ufffd&lt;char32_t&gt;;
  template &lt;&gt; struct ufffd&lt;wchar_t&gt;;

  //  [uni.encoding] encoding types
  struct narrow {typedef char     value_type;}; // codecvt determined encoding
  struct utf8   {typedef char     value_type;}; // UTF-8 encoding
  struct utf16  {typedef char16_t value_type;}; // UTF-16 encoding
  struct utf32  {typedef char32_t value_type;}; // UTF-32 encoding
  struct wide   {typedef wchar_t  value_type;}; // wide-character literal
                                                //   encoding [lex.ccon]

  // [uni.is_encoding] is_encoding type-trait
  template &lt;class T&gt; struct is_encoding : public std::false_type {};
  template&lt;&gt; struct is_encoding&lt;narrow&gt; : std::true_type {};
  template&lt;&gt; struct is_encoding&lt;utf8&gt;   : std::true_type {};
  template&lt;&gt; struct is_encoding&lt;utf16&gt;  : std::true_type {};
  template&lt;&gt; struct is_encoding&lt;utf32&gt;  : std::true_type {};
  template&lt;&gt; struct is_encoding&lt;wide&gt;   : std::true_type {};

  template &lt;class T&gt; constexpr bool is_encoding_v = is_encoding&lt;T&gt;::value;

  // [uni.is_encoded_character] is_encoded_character type-trait
  template &lt;class T&gt; struct is_encoded_character   : public std::false_type {};
  template&lt;&gt; struct is_encoded_character&lt;char&gt;     : std::true_type {};
  template&lt;&gt; struct is_encoded_character&lt;char16_t&gt; : std::true_type {};
  template&lt;&gt; struct is_encoded_character&lt;char32_t&gt; : std::true_type {};
  template&lt;&gt; struct is_encoded_character&lt;wchar_t&gt;  : std::true_type {};

  template &lt;class T&gt; constexpr bool is_encoded_character_v
    = is_encoded_character&lt;T&gt;::value;

  //  [uni.codecvt.facet] wide to/from narrow codecvt facet type 
  typedef codecvt&lt;wchar_t, char, std::mbstate_t&gt; ccvt_type;

  //  [uni.recode] encoding conversion algorithm
  template &lt;class FromEncoding, class ToEncoding,
    class InputIterator, class OutputIterator, class ... T&gt;
  OutputIterator recode(InputIterator first, InputIterator last,
                        OutputIterator result, const T&amp; ... args);

  //  [uni.to_string] string encoding conversion
  template &lt;class ToEncoding, class FromEncoding, class ... T&gt;
    basic_string&lt;typename ToEncoding::value_type&gt;
      to_string(basic_string_view&lt;typename FromEncoding::value_type&gt; v,
                const T&amp; ... args);

  // [uni.utf-query] UTF encoding queries
  template &lt;class Encoding, class ForwardIterator&gt; inline
    ForwardIterator first_ill_formed(ForwardIterator first,
      ForwardIterator last) noexcept;
  template &lt;class Encoding&gt; inline
    bool is_well_formed(basic_string_view&lt;typename Encoding::value_type&gt; v)
     noexcept;

}  // namespace unicode
}  // namespace fundamentals_v2
}  // namespace experimental
}  // namespace std</pre>



<h3>Character type, encoding type, and encodings [uni.relationships]</h3>

<p>The 
relationship between character types, encoding types, and encodings is specified by the following 
table:</p>

<blockquote>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="942">
  <tr>
    <td width="100"><b>Character type</b></td>
    <td width="96"><b>Encoding type</b></td>
    <td width="712"><b>Encoding</b></td>
  </tr>
  <tr>
    <td width="100"><code>char</code></td>
    <td width="96"><code>narrow</code></td>
    <td width="712">The encoding of characters of type <code>char</code> for a user-supplied 
    object 
    of a type derived from <code>std::codecvt&lt;wchar_t, char, mbstate_t&gt;</code> 
    which shall meet the requirements of the standard code-conversion facet
    <code>std::codecvt&lt;Elem, char, std::mbstate_t&gt;</code>. (C++ [locale.codecvt]).
    <i><span style="background-color: #C0C0C0">&quot;which shall meet...&quot; wording 
    copied from C++ [conversions.string].</span></i></td>
  </tr>
  <tr>
    <td width="100"><code>char</code></td>
    <td width="96"><code>utf8</code></td>
    <td width="712">UTF-8 (UCS 9.2).</td>
  </tr>
  <tr>
    <td width="100"><code>char16_t</code></td>
    <td width="96"><code>utf16</code></td>
    <td width="712">UTF-16 (UCS 9.3).</td>
  </tr>
  <tr>
    <td width="100"><code>char32_t</code></td>
    <td width="96"><code>utf32</code></td>
    <td width="712">UFT-32 (UCS 9.4)</td>
  </tr>
  <tr>
    <td width="100"><code>wchar_t</code></td>
    <td width="96"><code>wide</code></td>
    <td width="712">The encoding of wide-character literals (C++ [lex.ccon]). </td>
  </tr>
</table>
</blockquote>



<h4>Error handling [uni.err]</h4>



<p>When an ill-formed code unit subsequence is detected during execution of a 
conversion function, an <i>error handler</i> function object shall be invoked. Unless 
the error handler throws an exception, the string returned by the error handler 
shall be added to the output sequence and the ill-formed input code unit subsequence 
shall not be converted and added to the output sequence. Detection of ill-formed code unit 
subsequences is required even when the input and output encodings are the same. 
[<i>Note:</i> If the error handler function object always returns a 
well-formed UTF character sequence, the conversions function&#39;s entire output 
sequence is a well-formed UTF sequence. &mdash; <i>end note</i>]</p>

<pre>template &lt;class CharT&gt; struct ufffd;
template &lt;&gt; struct ufffd&lt;char&gt;;
template &lt;&gt; struct ufffd&lt;char16_t&gt;;
template &lt;&gt; struct ufffd&lt;char32_t&gt;;
template &lt;&gt; struct ufffd&lt;wchar_t&gt;;</pre>


<p><code>struct ufffd</code> is the default error handler function object for conversion functions. 
The default error 
handling function object returns U+FFFD REPLACEMENT CHARACTER as a single code point error marker. Each specialization shall provide a member function with the signature:</p>

<blockquote>


<p> <code>constexpr CharT* operator()() const noexcept;</code></p>

</blockquote>


<p>that returns a pointer to the value indicated in the Specializations table: </p>

<blockquote>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
<tr><td colspan="2"><p align="center"><i><b>Specializations</b></i></td></tr>
<tr><td><i><b><code>CharT</code></b></i></td><td><i><b>Returns</b></i></td></tr>
<tr><td><code>char</code></td><td><code>u8&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>u&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>char32_t</code></td><td><code>U&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>wchar_t</code></td><td><code>L&quot;\uFFFD&quot;</code></td></tr>
</table>
</blockquote>

  <p>[<i>Note:</i> U+FFFD REPLACEMENT CHARACTER is returned as the default 
  single code point error marker in accordance with the recommendations of the Unicode Standard. 
  The rationale given by the Unicode standard is essentially that other commonly used approaches, including 
  throwing exceptions, can be and have been used as security attack vectors.
  &mdash;<i>end note</i>]</p>

<h4>Encoding conversion algorithm [uni.recode]</h4>

<pre>template &lt;class FromEncoding, class ToEncoding,
  class InputIterator, class OutputIterator, class ... T&gt;
OutputIterator recode(InputIterator first, InputIterator last,
                      OutputIterator result, const T&amp; ... args);</pre>
    
  <blockquote>
     <p><i>Effects:</i> For each minimal well-formed or ill-formed code unit 
     subsequence in the range [<code>first, last</code>):</p>
     <ul>
       <li>
       <p>If the code unit subsequence is well-formed, copies the subsequence&#39;s 
       Unicode scalar value by performing <code>*result++ = *u++</code> where 
       <code>u</code> 
       is a <code>ToCharT*</code> pointing to the code units required to 
       represent the subsequence&#39;s Unicode scalar value in the encoding form of <code>
       result</code>.</li>
       <li>
       <p>Otherwise, copies the null-terminated string returned by the <code>eh</code> 
       function object by performing <code>*result++ = *p++</code> for each 
       successive value of a pointer <code>p</code> to the returned string.</li>
     </ul>
     <p><i>Returns: </i><code>result</code>.</p>
     <p><i>Remarks:</i>&nbsp; The requirements for the <code>args</code> 
     parameter pack arguments are shown in the following table.</p>
  </blockquote>
    
     <div align="center">
       <center>

    
     <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
       <tr>
         <td><b><code>FromEncoding</code></b></td>
         <td><b><code>ToEncoding</code></b></td>
         <td>
         <p><b>First <code>args</code> argument</b></td>
         <td><b>Second <code>args</code> argument</b></td>
         <td><b>Third <code>args</code> argument</b></td>
       </tr>
       <tr>
         <td><code>utf8</code>, <code>utf16</code>,<br>
         <code>utf32</code>, or <code>
         wide</code></td>
         <td><code>utf8</code>, <code>utf16</code>,<br>
         <code>utf32</code>, or <code>
         wide</code></td>
         <td>Optional error handler function object [uni.err]</td>
         <td>Not allowed; diagnostic required</td>
         <td>Not allowed; diagnostic required</td>
       </tr>
       <tr>
         <td><code>utf8</code>, <code>utf16</code>,<br>
         <code>utf32</code>, or <code>
         wide</code></td>
         <td><code>narrow</code></td>
         <td><code>const ccvt_type&amp; ccvt</code></td>
         <td>Optional error handler function object [uni.err]</td>
         <td>Not allowed; diagnostic required</td>
       </tr>
       <tr>
         <td><code>narrow</code></td>
         <td><code>utf8</code>, <code>utf16</code>,<br>
         <code>utf32</code>, or <code>
         wide</code></td>
         <td><code>const ccvt_type&amp; ccvt</code></td>
         <td>Optional error handler function object [uni.err]</td>
         <td>Not allowed; diagnostic required</td>
       </tr>
       <tr>
         <td><code>narrow</code></td>
         <td><code>narrow</code></td>
         <td><code>const ccvt_type&amp; from_ccvt</code></td>
         <td><code>const ccvt_type&amp; to_ccvt</code></td>
         <td>Optional error handler function object [uni.err]</td>
       </tr>
     </table>
       </center>
     </div>
     
   <blockquote>
    
     <p><i>Postcondition: </i>If the string returned by each call to the <code>
     eh</code> function object during the execution of the algorithm is a well 
     formed  sequence, then the output sequence is a well formed  sequence.</p>
    
    
<p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Example:</span></i><span style="background-color: #FFFF00"> xxx &mdash;</span><i><span style="background-color: #FFFF00">end example</span></i><span style="background-color: #FFFF00">]</span></p>

    
  </blockquote>                           
    
    
<h4>String encoding conversion [uni.to_string]</h4>

<pre>template &lt;class ToEncoding, class FromEncoding, class ... T&gt;
  basic_string&lt;typename ToEncoding::value_type&gt;
    to_string(basic_string_view&lt;typename FromEncoding::value_type&gt; v,
              const T&amp; ... args);
</pre>
<blockquote>
    
    
<p><i>Effects:</i> Equivalent to:</p>

<blockquote>
    
    
<p><code>basic_string&lt;typename ToEncoding::value_type&gt; tmp;<br>
recode&lt;FromEncoding, ToEncoding&gt;(v.cbegin(), v.cend(), <br>
&nbsp; back_inserter(tmp), args ...);<br>
return tmp;</code></p>

</blockquote>
    
    
<p><i>Remarks:</i> This function shall not participate in overload resolution 
unless <code>is_encoding_v&lt;ToEncoding&gt;</code> &amp;&amp; <code>is_encoding_v&lt;FromEncoding&gt;</code> 
is <code>true</code>.</p>

</blockquote>
    
    
<h4>UTF encoding queries [<a name="uni.enc_err_detect">uni.utf-query</a>]</h4>

    
<p>These functions determine whether or not character sequences and strings consist of 
well-formed code unit sequences (UCS 4.61). </p>

<pre>template &lt;class Encoding, class ForwardIterator&gt; inline
&nbsp; ForwardIterator first_ill_formed(ForwardIterator first, ForwardIterator last)
    noexcept;&nbsp;</pre>
  <blockquote>
     <p><i>Returns: </i>The first iterator <code>iter</code> in the range <code>
     [first, last)</code> for which <code>iter</code> points to the start of a minimal ill-formed code unit 
     subsequence. Returns <code>last</code> if no ill-formed code unit 
     subsequence is found.</p>
     <p><i>Remarks:</i>&nbsp; The specific UTF encoding form is determined by the <code>
     ForwardIterator</code> value type ([uni.relationships]).</p>
  </blockquote>                           

<pre>template &lt;class Encoding&gt; inline
&nbsp;&nbsp;bool is_well_formed(basic_string_view&lt;typename Encoding::value_type&gt; v)
&nbsp; &nbsp; noexcept;&nbsp;</pre>
  <blockquote>
     <p><i>Returns: </i>Equivalent to <code>first_ill_formed(v.cbegin(), v.cend()) 
     == v.cend()</code>.</p>
  </blockquote>                           
<hr>

</body>

</html>