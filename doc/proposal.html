<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
  body
  {
    font-family: arial, sans-serif;
    max-width: 6.75in;
    margin: 0px auto;
    font-size: 85%;
  }
   ins  {background-color: #CCFFCC; text-decoration: none;}
   del  {background-color: #FFCACA; text-decoration: none;}
   pre  {background-color: #D7EEFF; font-family: "courier new", courier, serif;}
   code {font-family: "courier new", courier, serif;}
   table {font-size: 90%;}
</style>
<title>Unicode Encoding conversions</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">DxxxxR0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-05-21<!--webbot bot="Timestamp" endspan i-checksum="12330" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>



<h1 align="center">Unicode Encoding Conversions for the Standard Library</h1>

<p  style="margin-left:20%; margin-right:20%;">Proposes Unicode Transformation 
Form (UTF) encoding conversion functions to ease interoperability between the 
standard library&#39;s different character string types. Pure addition to the standard library. 
Proposes no changes to the 
core language or existing standard library components. Breaks no existing code 
or ABI. Specified in accordance with the Unicode Standard. Proposed wording 
provided. Has been implemented. Suitable for 
either a Library TS or the standard itself.</p>



<h2>Motivation</h2>



<p dir="ltr">Modern C++ character types <code>char</code>, <code>char16_t</code>, 
and
<code>char32_t</code> support 
Unicode Transformation Forms UTF-8, UTF-16, and UTF-32 respectively. Character 
type <code>wchar_t</code> also supports one of these depending on its size. 
Character and string literals and several forms of strings are supported for 
these character types. Use of more than one UTF encoding may appear in the same 
application, or even the same function. Yet neither the language nor the 
standard library provides a modern, convenient way to convert between encodings. 
There is no equivalent to the ease with which <code>std::to_string</code> can 
convert an arithmetic value to a string. This proposal solves the problems for 
users by the lack of Unicode encoding conversions in the standard libary.</p>



<h2>Prior proposal</h2>



<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3398.html">
N3398</a>, <i>String Interoperation Library</i>, proposed a complete overhaul of 
the standard library&#39;s mechanisms for character encoding conversion. The 
proposal was discussed at the Portland meeting in 2012. Some aspects of the 
proposal drew strong support, such as improving Unicode string interoperability. 
Other aspects drew strong opposition, such as new low level functionality to 
replace <code>std::codecvt</code>. Clearly participants did not want N3398 - 
they wanted a different proposal, less overreaching and more focused on Unicode 
encoding conversions. The best sound bite came from PJ Plauger who said roughly 
&quot;Don&#39;t reinvent <code>codecvt</code>. That said, we should pick a winner - 
Unicode.&quot;</p>



<p>The current proposal is completely new and not a revision of N3398.</p>



<h2>Implementation</h2>



<p>A Boost licensed preliminary implementation is available at
<a href="https://github.com/Beman/unicode">github.com/Beman/unicode</a>.
<span style="background-color: #FFFF00">Need to resolve or describe differences 
between proposal and implementation.</span></p>



<h2>Acknowledgements</h2>



<p dir="ltr">Alisdair Meredith, Eric Niebler, Howard Hinnant, Jeffrey Yasskin, 
Marshall Clow, PJ Plauger, and Stephan T. Lavavej participated in the Portland 
discussion of N3398. Many of the design decisions going into the current new 
proposal flow directly from the Portland discussion.</p>



<p>After the Portland meeting, Matt Austern sat down with Google&#39;s Unicode 
people to &quot;clarify things&quot;. His summary of that discussion was very helpful, and 
its guidance on error handling is strongly reflected in the current new 
proposal.</p>



<h2>Design decisions</h2>



<p><b>Limit this proposal on UTF encoding conversion</b></p>



  <ul>
    <li>Getting UTF encoding conversion right is hard enough without also coping 
    with non-conversion related needs.</li>
    <li>No single all encompassing Unicode proposal is on the horizon.</li>
    <li>Other needs requested by domain experts, such as code point iterators, 
    are important enough to deserve their own proposals.</li>
    <li>Guidance from both the committee and domain experts clearly favors a 
    proposal focusing on UTF conversions.</li>
    <li>UTF encoding conversions can use character type alone to determine 
    encoding, and this results in simpler conversion interfaces and no need to 
    add a <code>char8_t</code> character type to the core language.</li>
  </ul>



<p><b>Provide three levels of functionality</b></p>
<blockquote>



<p>Provide high-level convenience encoding conversion functions that handle 
everyday string interoperability needs. Keep the interfaces simple, but do 
support error handling customization since error handling needs vary widely. For 
example:</p>



<blockquote>



<p><code>string u8str = u16str;</code></p>



</blockquote>



<p>Provide mid-level generic string conversion functions to support those requiring 
generic string interoperability needs. For example:</p>



<blockquote>



<p><code>void g(std::string_view v);&nbsp; // requires UTF-8 encoding<br>
<br>
template &lt;class StringView&gt;<br>
void f(StringView v) { g(to_u8string(v)); }</code></p>



</blockquote>



<p>For UTF encoding conversions, provide a low-level encoding conversion algorithm patterned after existing standard 
library algorithms for users who need to perform encoding conversions on 
sequences of characters.</p>
<blockquote>



<p>&nbsp;</p>
</blockquote>



<p>Differing user needs is the primary motivation for providing three levels of 
functionality. Meshing well with existing standard library components such as 
algorithms and the <code>to_string</code> function family is an additional 
benefit.</p>
</blockquote>



<p><b>Provide a coherent error detection and handling policy</b></p>



<ul>
  <li>Follow the Unicode standard&#39;s requirement that &quot;A conformant encoding form 
  conversion will treat any ill-formed code unit<br>
  sequence as an error condition.&quot; (Unicode 3.9 D93 and C10).</li>
  <li>Provide a note to inform users of as to when they do and do not have to 
  explicitly check for errors themselves.</li>
  <li>Provide error checking functions so that users can also explicitly check for errors 
  to meet application needs.</li>
  <li>Handle errors via function objects to support varied user needs 
  requested by domain experts.</li>
  <li>Default error handler function object to follow the Unicode standard&#39;s 
  recommendation of U+FFFD as a replacement character to minimize security 
  risks.</li>
</ul>



<p><b>Provide encoding conversions as explicitly called non-member functions</b></p>



<ul>
  <li>Avoids possibly expensive hidden automatic encoding conversions in 
  unexpected places.</li>
  <li>Avoids the need to change existing standard library components.</li>
  <li>Meshes well with the other <code>to_string</code> functions already in the 
  standard library.</li>
</ul>



<p><b>Support <code>wchar_t</code> as well as <code>char</code>, <code>char16_t</code>, 
and <code>char32_t</code></b></p>



<ul>
  <li dir="ltr">
  <p dir="ltr"><code>wchar_t</code> strings are the bridge to and from non-UTF encoded
  <code>char</code> strings, via existing standard library components using 
  codecvt facets. This requires that <code>wchar_t</code> strings are UTF 
  encoded, just as we require <code>char16_t</code> and <code>char32_t</code> 
  strings are UTF encoded.</li>
</ul>



<p><b>Place the proposed components in a <code>unicode</code> namespace</b></p>



<ul>
  <li>A separate scope emphasizes that these functions assume <code>
  char</code> strings are UTF-8 encoded.</li>
  <li>Provides a home for these and future Unicode specific functions.</li>
</ul>



<p><b>Keep interfaces neutral as to which character type or UTF encoding is 
&quot;best&quot;</b></p>



<ul>
  <li>



<p>Each of these encodings have uses where one is preferred or required, and all 
of these encoding forms may appear in the same application.</p>



<blockquote>



<p>Examples:</p>



  <ul>
    <li>The API&#39;s for some operating systems require UTF-8.</li>
    <li>Interfacing with existing databases may require UTF-16.</li>
    <li>Applications code uses UTF-32 for single characters because every 
    Unicode code point can be encoded as a single code unit.</li>
  </ul>
</blockquote>



  </li>
</ul>
<h2>Open questions</h2>
<p>If P0254, <i>Integrating <code>std::string_view</code> and <code>std::string</code></i>, 
is accepted, then the proposed wording below needs to be reviewed to accommodate 
changes that may accrue. Such changes, if any, are expected to be minor.</p>
<p>Should an error handler that throws an exception be provided? Although the 
uffd error handler is clearly the most conservative default, the preferred 
choice for applications that are working with supposedly well-formed UTF 
encodings may want an exception thrown if an ill-formed encoding is encountered.</p>
<p>Should a new exception type such as <code>encoding_error</code> be provided?</p>
<h2>To do</h2>
<p>Add sequence and string error-checking functions that detect ill formed 
encodings.</p>
<p>Add arguments for error handler function objects:</p>
<ul>
  <li>The location of the error in the input sequence. Probably the iterator of 
  the point where the error was detected.</li>
  <li>The specifics of the error. Probably an error type enum for the specific 
  encoding form errors called out in the Unicode Standard.</li>
</ul>
<h2>Bikeshed</h2>
<p>Namespace choice:</p>
<blockquote>
<p>utf<br>
unicode</p>
</blockquote>

<h2>Proposed wording</h2>

<h2>Unicode library</h2>

<h3>Normative references</h3>

<p>The <i>Unicode Standard</i>,
<a href="http://www.unicode.org/versions/latest/">
www.unicode.org/versions/latest/</a>, is indispensable for the application of 
this document.<sup><font face="Arial">[footnote]</font></sup> The latest edition
(including any amendments) applies. A reference to the Unicode Standard  
written in the form &quot;(Unicode 3.4 D10)&quot; refers to the Unicode Standard, Core 
Specification, chapter 3, section 4, sub-section D10.</p>

<p>For convenience, portions of the Unicode Standard are quoted 
herein. Any conflicts between those quotes and the Unicode Standard is 
unintentional and should be resolved by reference to the actual Unicode Standard 
document.</p>

<p><sup><font face="Arial">[Footnote]</font></sup> Unicode® is a registered 
trademark of Unicode, Inc. This information is given for the convenience of 
users of this document and does not constitute an endorsement by ISO or IEC of 
this product.</p>

<h3>Definitions</h3>

<h4>Code point (Unicode 3.4 D10)</h4>
<p>&quot;Any value in the Unicode codespace. Informally, a code point can be thought 
of as a Unicode character.&quot; </p>
<blockquote>
  <p>(Unicode Appendix A - Notational Conventions): </p>
  <p>&quot;In running text, an individual Unicode code point is expressed as U+n, 
  where n is four to six hexadecimal digits, using the digits 0–9 and uppercase 
  letters A–F (for 10 through 15, respectively). Leading zeros are omitted, 
  unless the code point would have fewer than four hexadecimal digits—for 
  example, U+0001, U+0012, U+0123, U+1234, U+12345, U+102345. </p>
  <p>[e.g.] U+0416 is the Unicode code point for the character named CYRILLIC 
  CAPITAL LETTER ZHE.&quot; </p>
</blockquote>

<h4>Code unit (Unicode 3.9 D77)</h4>
<p>&quot;The minimal bit combination that can represent a unit of encoded text for 
processing or interchange. Code units are particular units of computer storage. 
... The Unicode Standard uses 8-bit code units in the UTF-8 encoding form, 
16-bit code units in the UTF-16 encoding form, and 32-bit code units in the 
UTF-32 encoding form.&quot;</p>
<blockquote>
  <p>[<i>Note:</i> In C++ one <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or 
  <code>char32_t</code> character holds one 
  code unit.
  One to four code units (type <code>char</code>) are required to hold a UTF-8 
  encoded code 
  point.
  One or two code units (type <code>char16_t</code>) are required to hold a UTF-16 encoded 
  code point.
  One code unit (type <code>char32_t</code>) is required to hold a UTF-32 code point. 
  Type <code>wchar_t</code> may use 8, 16, or 32-bit code units, encoded as 
  UTF-8, UTF-16, or UTF-32, respectively, so will  require 4, 2, or 1 code units
  to hold a code point depending on the encoding.&mdash;<i>end note</i>]</p>
</blockquote>

  <h4>Unicode encoding forms (Unicode 3.9)</h4>

  <p>&quot;The Unicode Standard supports three character encoding forms: UTF-32, 
  UTF-16, and UTF-8. Each encoding form maps the Unicode code points 
  U+0000..U+D7FF and U+E000..U+10FFFF to unique code unit sequences. The size of 
  the code unit is specified for each encoding form. This section (Unicode 3.9) 
  presents the formal definition of each of these encoding forms.&quot;</p>
  <p>For formal definitions of UTF-32, UTF-16, and UTF-8, see
  <a href="http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G7404">Section 
  3.9, Unicode Encoding Forms</a> in <em>The Unicode Standard</em>. </p>

<p>[Note: For general questions related to Unicode transformation 
form (UTF), UTF-8, UTF-16, UTF-32, or byte order marks (BOM), see
<a href="http://unicode.org/faq/utf_bom.html">unicode.org/faq/utf_bom.html</a>.&mdash;<i>end note</i>]</p>

<h4>Well-formed (Unicode 3.9 D85)</h4>

<p>&quot;A Unicode code unit sequence that purports to be in a Unicode encoding form 
is called well-formed if and only if it does follow the specification of that 
Unicode encoding form.&quot;</p>

<h4>Minimal well-formed code unit subsequence (Unicode 3.9 D85a)</h4>

<p>&quot;A well-formed Unicode code unit sequence that maps to a single Unicode 
scalar value.</p>


<blockquote>
  <ul>
    <li>For UTF-8, see the specification in Unicode 3.9 D92 and Table 3-7.</li>
    <li>For UTF-16, see the specification in Unicode 3.9 D91.</li>
    <li>For UTF-32, see the specification in Unicode 3.9 D90.&quot;</li>
  </ul>
</blockquote>

<h3>Header &lt;experimental/unicode&gt; synopsis</h3>

<pre>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {
namespace unicode {

  //  Error function objects are called with no arguments and either throw an
  //  exception or return a const pointer to a possibly empty C-style string.

  //  default error handler: function object returns a C-string of type
  //  ToCharT with a UTF encoded value of U+FFFD.

  // [uni.err], error handling
  template &lt;class CharT&gt; struct ufffd;
  template &lt;&gt; struct ufffd&lt;char&gt;;
  template &lt;&gt; struct ufffd&lt;char16_t&gt;;
  template &lt;&gt; struct ufffd&lt;char32_t&gt;;
  template &lt;&gt; struct ufffd&lt;wchar_t&gt;;

  //  [uni.enc_cvt_alg], string encoding conversion algorithm
  template &lt;class ToCharT, class InputIterator, class OutputIterator,
    class Error = typename ufffd&lt;ToCharT&gt;&gt;
  OutputIterator convert_utf(InputIterator first, InputIterator last, 
                             OutputIterator result, Error eh = Error());

  //  [uni.gen_enc_cvt], string encoding generic conversions
  template &lt;class ToCharT, class FromCharT,
    class FromTraits = typename char_traits&lt;FromCharT&gt;,
    class View = basic_string_view&lt;FromCharT, FromTraits&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = char_traits&lt;ToCharT&gt;,
    class ToAlloc = allocator&lt;ToCharT&gt;&gt;
  basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    to_utf_string(View v, Error eh = Error(), const ToAlloc&amp; a = ToAlloc());
  
  //  [uni.conv_enc_cvt], string encoding convenience conversions
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(wstring_view v, Error eh = Error());

}  // namespace unicode
}  // namespace fundamentals_v2
}  // namespace experimental
}  // namespace std</pre>



<h3>UTF encoding conversion functions [uni.enc_cvt]</h3>

<p>UTF conversion functions determine encoding based on character type. The 
relationship between character type and encoding is specified by the following 
table:</p>

<blockquote>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="2">
    <p align="center"><b><i>UTF Conversions</i></b></td>
      </tr>
  <tr>
    <td><b>Character Type</b></td>
    <td><b>Encoding</b></td>
  </tr>
  <tr>
    <td><code>char</code></td>
    <td>UTF-8</td>
  </tr>
  <tr>
    <td><code>char16_t</code></td>
    <td>UTF-16</td>
  </tr>
  <tr>
    <td><code>char32_t</code></td>
    <td>UFT-32</td>
  </tr>
  <tr>
    <td><code>wchar_t</code></td>
    <td>UTF-8, 16, or 32</td>
  </tr>
</table>
</blockquote>



<h4>Error handling [uni.err]</h4>

<p>&nbsp;</p>

<p>Errors in input encoding are detected, even when the input and output 
encodings are the same. The eh function object&#39;s returned sequence if any 
replaces the invalid input encoding in the output, even when the input and 
output encodings are the same. This implies that if the eh function object 
always returns a valid UTF character sequence, the overall function output 
sequence is a valid UTF sequence.<br>
&nbsp;</p>



<p>&nbsp;</p>

<pre>template &lt;class CharT&gt; struct ufffd;
template &lt;&gt; struct ufffd&lt;char&gt;;
template &lt;&gt; struct ufffd&lt;char16_t&gt;;
template &lt;&gt; struct ufffd&lt;char32_t&gt;;
template &lt;&gt; struct ufffd&lt;wchar_t&gt;;</pre>


<p><code>struct ufffd</code> provides the default error handling function object for the conversion functions. Each specialization shall provide a member function with the signature:</p>

<blockquote>


<p> <code>constexpr CharT* operator()() const noexcept;</code></p>

</blockquote>


<p>that returns the value indicated in the Specializations table: </p>

<blockquote>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
<tr><td colspan="2"><p align="center"><i><b>Specializations</b></i></td></tr>
<tr><td><i><b><code>CharT</code></b></i></td><td><i><b>Returns</b></i></td></tr>
<tr><td><code>char</code></td><td><code>u8&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>u&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>char32_t</code></td><td><code>U&quot;\uFFFD&quot;</code></td></tr>
<tr><td><code>wchar_t</code></td><td><code>L&quot;\uFFFD&quot;</code></td></tr>
</table>
</blockquote>

<p>In accordance with the Unicode Standard&#39;s recommendations (<span style="background-color: #FFFF00">need 
reference</span>), the default error 
handling function object <code>ufffd</code> returns U+FFFD REPLACEMENT CHARACTER as a single code point error marker.</p>

<blockquote>
  <p>[<i>Note:</i> U+FFFD REPLACEMENT CHARACTER is returned as the default 
  single code point error marker in accordance with the recommendations of the Unicode Standard. 
  The rationale given is essentially that other commonly used approaches, including 
  throwing exceptions, can be and have been used as security attack vectors.
  &mdash;<i>end note</i>]</p>
</blockquote>

<h4>Encoding conversion algorithm [uni.enc_cvt_alg]</h4>

<pre>template &lt;class ToCharT, class InputIterator, class OutputIterator,
          class Error = typename ufffd&lt;ToCharT&gt;&gt;
  OutputIterator convert_utf(InputIterator first, InputIterator last, 
                             OutputIterator result, Error eh = Error());</pre>
  <blockquote>
     <p><i>Effects:</i> For each minimal well-formed or ill-formed code unit 
     subsequence in the range [<code>first, last</code>):</p>
     <ul>
       <li>
       <p>If the code unit subsequence is well-formed, copies the 
       subsequence&#39;s Unicode scalar value by performing <code>*result++ = *u++</code> 
       where u is a <code>ToCharT*</code> pointing to the code units required to represent the 
       subsequence&#39;s Unicode 
       scalar value in the encoding form of <code>result</code>.</li>
       <li>
       <p>Otherwise, copies the null-terminated string returned by the <code>eh</code> function 
       object by performing <code>*result++ = *p++</code> for each successive 
       value of a pointer <code>p</code> to the returned string.</li>
     </ul>
     <p><i>Returns: </i><code>result</code>.</p>
     <p><i>Remarks:</i>&nbsp; The Unicode encoding form for the range [<code>first, 
     last</code>) is determined by <code>InputIterator</code> value type ([uni.enc_cvt]). The 
     Unicode encoding form for <code>result</code> is determined by <code>
     ToCharT</code> ([uni.enc_cvt]).</p>
  </blockquote>                           

<h4>Generic string encoding conversion functions [uni.gen_enc_cvt]</h4>

<pre> template &lt;class ToCharT, class FromCharT,
    class FromTraits = typename char_traits&lt;FromCharT&gt;,
    class View = basic_string_view&lt;FromCharT, FromTraits&gt;,
    class Error = ufffd&lt;ToCharT&gt;,
    class ToTraits = char_traits&lt;ToCharT&gt;,
    class ToAlloc = allocator&lt;ToCharT&gt;&gt;
  basic_string&lt;ToCharT, ToTraits, ToAlloc&gt;
    to_utf_string(View v, Error eh = Error(), const ToAlloc&amp; a = ToAlloc());</pre>

  <blockquote>
     <p><i>Returns:</i> Equivalent to:</p>
     <blockquote>
     <p><code>basic_string&lt;ToCharT, ToTraits, ToAlloc&gt; tmp(a);<br>
     convert_utf&lt;ToCharT&gt;(v.cbegin(), v.cend(), back_inserter(tmp), eh);<br>
     return tmp;</code></p>
     </blockquote>
  </blockquote>                           

<h4>Convenience string encoding conversion functions [uni.conv_enc_cvt]</h4>

<pre>template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char&gt;&gt;
    string to_u8string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char16_t&gt;&gt;
    u16string to_u16string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;char32_t&gt;&gt;
    u32string to_u32string(wstring_view v, Error eh = Error());

  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u16string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(u32string_view v, Error eh = Error());
  template &lt;class Error = ufffd&lt;wchar_t&gt;&gt;
    wstring to_wstring(wstring_view v, Error eh = Error());</pre>

  <blockquote>
     <p><i>Returns:</i> Equivalent to: </p>
     <blockquote>
     <p> <code>to_utf_string&lt;<i>r_value_type</i>,
     <i>v_value_type</i>, Error&gt;(v, eh)</code> where <i><code>r_value_type</code></i> 
     is the <code>value_type</code> of the <code>basic_string</code> to be 
     returned and <i>
     <code>v_value_type</code></i> is the <code>value_type</code> of <code>v</code>.</p>
     </blockquote>
  </blockquote>                           

<h4>Encoding conversion stream inserters and extractors</h4>

<p><i><span style="background-color: #FFFF00">What do we do about </span>
<span style="background-color: #FFFF00">ADL</span><span style="background-color: #FFFF00"> 
if this goes in </span><span style="background-color: #FFFF00">std::experimental</span><span style="background-color: #FFFF00">::fundamentals_v2?</span></i></p>

<pre>&nbsp; //&nbsp; basic_string_view overload
&nbsp; template &lt;class ToCharT, class ToTraits, class FromCharT, class FromTraits&gt;
&nbsp; typename enable_if_c&lt;!is_same&lt;ToCharT, FromCharT&gt;::value,
&nbsp;&nbsp;&nbsp; basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; basic_string_view&lt;FromCharT, FromTraits&gt; v);

&nbsp; //&nbsp; basic_string overload
&nbsp; template &lt;class ToCharT, class ToTraits, class FromCharT, class FromTraits, class Alloc&gt;
&nbsp; typename enable_if_c&lt;!is_same&lt;ToCharT, FromCharT&gt;::value,
&nbsp;&nbsp;&nbsp; basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const basic_string&lt;FromCharT, FromTraits, Alloc&gt;&amp; s);

&nbsp; //&nbsp; pointer overload
&nbsp; //&nbsp;&nbsp;&nbsp; works despite std basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(const void* p) overload
&nbsp; template &lt;class ToCharT, class ToTraits, class FromCharT&gt;
&nbsp; typename enable_if_c&lt;!is_same&lt;ToCharT, FromCharT&gt;::value,
&nbsp;&nbsp;&nbsp; basic_ostream&lt;ToCharT, ToTraits&gt;&amp;&gt;::type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; operator&lt;&lt;(basic_ostream&lt;ToCharT, ToTraits&gt;&amp; os, const FromCharT* p);</pre>

<hr>

</body>

</html>