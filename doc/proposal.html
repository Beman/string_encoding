<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
  body
  {
    font-family: arial, sans-serif;
    max-width: 6.75in;
    margin: 0px auto;
    font-size: 85%;
  }
   ins  {background-color: #CCFFCC; text-decoration: none;}
   del  {background-color: #FFCACA; text-decoration: none;}
   pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
   code {font-size: 110%; font-family: "courier new", courier, serif;}
   table {font-size: 90%;}
</style>
<title>UTF Encoding Conversion</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left"><span style="background-color:yellow">DxxxxR0</span></td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-04-05<!--webbot bot="Timestamp" endspan i-checksum="12272" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library Evolution</td>
</tr>
</table>



<h2 >Requirements</h2>



<p ><b>[0] Break no existing code</b></p>



<p ><b>[1] No changes to the core language</b></p>



<p ><b>[2] No changes to the existing standard library</b></p>



<p ><b>[3] Support several use scenarios for <code>char</code>-based strings </b></p>
<ul>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  UTF-8 encoded.<ul>
  <li>Applies when UTF-8 is the default encoding for the operating system, and there 
  is no expectation of moving the code elsewhere, or</li>
  <li>Applies within a given section of code&nbsp;where <code>char</code>-based 
  strings are known to be UTF-8 encoded.</li>
</ul>



  </li>
  <li>User code where <code>char</code>-based strings can be assumed to be 
  non-UTF-8 encoded..<ul>
  <li>Applies when the default encoding for the operating system is not UTF-8, and 
  there is no expectation of moving the code elsewhere.</li>
  <li>Applies within a given section of code where <code>char</code>-based strings are 
  known to be non-UTF-8 encoded.</li>
</ul>



  </li>
  <li>Portable code that must make no assumptions about the default encoding of <code>
  char</code> based strings</li>
</ul>



<p ><b>[4] Utilize existing codecvt facets for conversions to and from <code>char</code> based strings 
that are not UTF 
encoded </b></p>



<h2 >Design decisions</h2>



<p ><b>No changes to the core language</b></p>
<blockquote>



<p >Types <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, and
<code>wchar_t</code> remain unchanged, and there is no change to current 
requirements on their encodings.</p>



<p >No new core language character types are proposed.</p>
</blockquote>



<p ><b>Proposed changes to the standard library are pure additions</b></p>



<p >&nbsp;</p>



<p ><b>Its all about string encoding needs</b></p>



<p ><b>Provide three levels of functionality</b></p>
<blockquote>



<p >Provide high-level easy-to-use encoding conversion functions that handle 
everyday string interoperability needs. Keep the interfaces simple, but do 
support error handling customization since user needs vary widely.</p>



<p >Provide mid-level generic string encoding to support those requiring the 
full range of string interoperability needs.</p>



<p >Provide a low-level encoding conversion algorithm patterned after existing standard 
library algorithms for those who need to perform encoding conversions on 
sequences of characters.</p>
</blockquote>



<p ><b>Provide the three levels of functionality for both codecvt-based and UTF-based 
conversions</b></p>



<blockquote>



<p ><b>Codecvt-based</b> </p>



</blockquote>



<p ><b>Default error handling in favor of security.</b></p>



<p ><b>Provide a coherent error detection policy so that users know when they do 
and when they do not have to check for errors themselves</b></p>



<p ><b>Provide error checking functions so that users can easily check strings 
or sequences for valid UTF encoding.</b></p>
<p ><b>Default encoding is Unicode Transformation Format (UTF)</b></p>
<p >Unless otherwise specified, all functions in namespace <code>
unicode</code> assume UTF-8, UTF-16, and UTF-32 encoding for <code>char</code>,
<code>char16_t</code>, and <code>char32_t</code> strings, respectively.</p>
<p ><code>wchar_t</code> strings are encoded as UTF-8, UTF-16, or 
UTF-32, depending on the encoding of <code>wchar_t</code>.</p>
<p ><b>Do not provide basic_string&lt;&gt; to/from ostream/istream converting 
operator&lt;&lt;/operator&gt;&gt;</b></p>
<p >Users can use to_u8|u16|u32|w_string UTF conversion functions. Implicit 
conversions lull users into ignoring the costs.</p>
<h2 >Open questions</h2>
<p >If P0254, <i>Integrating <code>std::string_view</code> and <code>std::string</code></i>, 
is accepted, then the Proposed wording needs to be reviewed to verify that no 
changes are required.</p>
<h2>TODO</h2>
<p >TODO: Also provide throwing error handler. Design for exception type to be 
thrown.</p>
<p >TODO: Add function that scans a sequence / string for errors, reports 
results.</p>
<p >TODO: Follow Marshall&#39;s suggested return of pair&lt;&gt; from string algorithms?</p>
<p >TODO: UTF first, last, iterators are InputIterators? 
ForwardIterators? RandomAccess? Contiguous? What does basic_string_view require? How does iterator category interact with error handler? If the actual 
conversion is done by functions requiring const char* point to a contiguous 
string, to lesser categories of iterators actually work?</p>
<p >TODO: Add test cases for other kinds of strings to regression 
tests</p>
<p >TODO: add static asserts on character types, other requirements.</p>
<p >TODO: Arguments for error handler?</p>
<h2 >Bikeshed</h2>
<p >Namespace choice:</p>
<blockquote>
<p >utf<br>
unicode</p>
</blockquote>
<h2 >Proposed wording</h2>
<p >&nbsp;</p>
<hr>

</body>

</html>